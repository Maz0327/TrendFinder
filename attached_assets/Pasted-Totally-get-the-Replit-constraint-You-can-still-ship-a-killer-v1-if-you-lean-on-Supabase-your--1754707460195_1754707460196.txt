Totally get the Replit constraint. You can still ship a killer v1 if you **lean on Supabase** (your Postgres + auth + cron) and keep anything heavy (video editing, ad APIs) out of your app for now.

Here’s what’s **realistic to implement fast** given your current codebase (extension → server → Supabase → Sheets) and a scrappy Replit setup.

---

# Reality check (Replit)

* ✅ Fine for a small Node server, APIs, and simple UIs.
* ✅ Great if you push compute to **Supabase** (DB, pgvector, cron/Edge Functions).
* ⚠️ Meh for background jobs/webhooks that must run 24/7 (Replit can sleep).
* ❌ Not good for heavy media work (FFmpeg, ML models), or direct ad-platform integrations needing approvals.

So we’ll **reuse what you already have**, add a few tables/fields, and keep exports simple (Sheets/Markdown/CSV).

---

# Green-light (do now, 1–2 weeks total)

## 1) Client Profiles + Brand-Fit ranking (low cost, high impact)

**Why:** Make every capture *for a specific client*, not generic.
**How:**

* Add `client_profiles` (niche, offers, voice sliders, taboo topics, priority platforms, risk posture).
* Add `client_id` to `briefs` and `captures` (or a join table).
* Add **embeddings** columns (Supabase `pgvector`) for both `client_profiles.persona_keywords` and `captures.text`.
* On save, call OpenAI **text-embedding-3-small** to store vectors (super cheap).
* Rank captures by **BrandFit = cosine(client, capture)** and **Recency** and a simple **Risk flag** (you already have truth/risk analysis).

**Outcome:** Your inbox shows **Top for Client A** with an obvious fit score so you know what to pitch.

---

## 2) PAC Drop Generator → Markdown & Google Sheets

**Why:** This is your weekly “Platforms & Culture” product (Vayner-style).
**How:**

* New route: `POST /pac/generate?client_id=&week=YYYY-WW&limit=10`
* It pulls top captures (by BrandFit x Attention), and for each creates:

  * Summary, *why it matters*, **3 post prompts**, **platform notes**, **paid boost angle**, **CTA**.
* Export to:

  * **Google Sheets** (you already have it) for distribution.
  * **Markdown** file (download) for easy copy→Docs.
* Save the brief as `briefs.type='PAC'` with snapshot of the LLM prompt + model version.

**Outcome:** One click → a client-ready weekly drop.

---

## 3) Sprint board + SLA timers (simple Kanban)

**Why:** Run the 2-week cadence solo without chaos.
**How:**

* Add `sprints` + `tasks` tables (columns: status, due\_at, assignee, client\_id, brief\_id).
* UI: columns = Capture → PAC → Brief → Draft → Approve → Publish → Boost → Report.
* SLA timers: if `now > due_at`, paint row red.
* **Notifications:** use Supabase **cron** (Edge Function) to send a daily digest email/Slack webhook (avoid relying on Replit background jobs).

**Outcome:** You always know what’s late, what’s next, what to publish/boost.

---

## 4) Boost Planner (CSV export + UTM builder)

**Why:** Turn organic winners into quick paid tests (the Vayner loop) without touching ad APIs yet.
**How:**

* Add “Mark as Winner” on a post/clip → **Boost Plan** object with:

  * Platform, objective, audience seed, budget bands (\$100/\$250/\$500), 2–3 copy variants, UTM params.
* Export **CSV** + **UTM’d links** to Sheets so you (or the client) can set up ads manually.

**Outcome:** You’re practicing “organic → paid amplification” with zero API pain.

---

## 5) Quote Bank + Vector Search

**Why:** Instant recall for hooks, thumbnails, and thought-leadership.
**How:**

* On transcript save, auto-extract **punchy quotes** (LLM) with tags (topic, emotion).
* Store each as its own record with an embedding.
* UI: search “pricing objection” → get quotes + clip timestamps.

**Outcome:** Faster hooks, faster carousels, smarter captions.

---

## 6) Reverse-Pyramid (lightweight)

**Why:** Pillar → 20–40 micro assets without video processing.
**How:**

* Input: a YouTube link or transcript file (you already can fetch/Whisper).
* LLM creates **clip suggestions** (start/end timestamps from transcript), **hook lines**, **caption options**, **platform crops** (spec notes), hashtags, and 1–2 **CTA variants**.
* Export an **edit list (CSV/JSON)** and **SRT** caption drafts. Let CapCut/Premiere do the heavy lifting manually.

**Outcome:** You generate all the *thinking* and templates; editing is fast and semi-manual (good enough for v1).

---

# Yellow-light (weekend projects)

* **Approval modes per client** (Pre-approved lanes vs Strict review) + decision log.
* **Competitor tracker (manual)**: save handles + scrape basic stats via share links, not APIs.
* **Slack slash-command** `/capture <url> <tag>` → hits your webhook and saves a capture (doesn’t need a full bot).
* **Notion export (optional)**: PAC drops directly into a Notion page via API.

---

# Red-light (save for later / not worth it on Replit right now)

* Heavy **video rendering/scene detection** (FFmpeg/ML).
* **Direct ad APIs** (Meta, LinkedIn) — approval + infra overhead.
* Always-on **webhook consumers** (rate limits + sleeping dynos).
* **Live social metrics ingestion** from private APIs.

---

# Minimal schema adds (so you can copy/paste into Supabase)

* `client_profiles(id, name, persona_keywords text, voice jsonb, taboo text[], platforms text[], risk_level text, created_at)`
* `captures.client_id uuid` (nullable)
* `client_profiles.embedding vector` and `captures.embedding vector`
* `sprints(id, name, start_at, end_at, client_id)`
* `tasks(id, sprint_id, client_id, brief_id, title, status, due_at, assignee, priority)`
* `boost_plans(id, capture_id, platform, objective, audiences jsonb, budget_band text, utm jsonb, notes)`
* `quotes(id, capture_id, text, topic, emotion, start_s, end_s, embedding vector)`

---

# What this gives you (practically)

* A **weekly PAC rhythm** you can run solo.
* Clear **client-specific prioritization** (BrandFit + Attention).
* The **reverse-pyramid** output without expensive compute.
* A **repeatable organic→paid** flywheel with manual boosts (still fast).
* A basic **ops layer** (sprints, SLAs) so nothing slips.

If you want, I’ll draft the **PAC Drop** endpoint spec + the **Reverse-Pyramid (light)** prompt & export schemas next, so you can build them straight away in Replit with your current stack.
