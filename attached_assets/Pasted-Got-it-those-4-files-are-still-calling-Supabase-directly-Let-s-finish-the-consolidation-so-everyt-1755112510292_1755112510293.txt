Got it â€” those 4 files are still calling Supabase directly. Letâ€™s finish the consolidation so everything goes through your Node/Express API. Below is a self-contained Replit Runbook the agent can execute. It creates a small HTTP client, resource services for Briefs/Captures/Moments/Feeds, refactors the hooks to use those services, and sanity-checks your server routes. It includes human pauses where you need to confirm things.

â¸»

ðŸ›  Replit Runbook â€” Remove Remaining Direct Supabase Calls (Client â†’ API)

Goal: Replace remaining direct Supabase calls in:
	â€¢	client/src/hooks/useBriefs.ts
	â€¢	client/src/hooks/useCaptures.ts
	â€¢	client/src/hooks/useMoments.ts
	â€¢	client/src/services/feeds.ts

with calls to your backend REST API (/api/...), while still using Supabase only for auth tokens.

â¸»

0) Preconditions (verify)
	â€¢	Ensure server is running and exposes these routes (or analogous):
	â€¢	Briefs: GET /api/briefs, POST /api/briefs, PUT /api/briefs/:id, DELETE /api/briefs/:id
	â€¢	Captures: GET /api/captures, POST /api/captures, PATCH /api/captures/:id, DELETE /api/captures/:id
	â€¢	Moments: GET /api/moments, POST /api/moments, PATCH /api/moments/:id, DELETE /api/moments/:id
	â€¢	Feeds (user_feeds): GET /api/feeds, POST /api/feeds, PATCH /api/feeds/:id, DELETE /api/feeds/:id
	â€¢	Frontend environment:
	â€¢	VITE_API_BASE_URL is unset (weâ€™ll default to /api) or set correctly.
	â€¢	Supabase client is used only to fetch the JWT (supabase.auth.getSession()).

If any route is missing, weâ€™ll generate minimal server handlers in step 5.

â¸»

1) Create a tiny HTTP client (auth-aware)

Create file: client/src/services/http.ts with:

import { supabase } from "@/integrations/supabase/client";

const API_BASE = import.meta.env.VITE_API_BASE_URL || "/api";

async function getAuthHeaders(): Promise<Headers> {
  const { data: { session } } = await supabase.auth.getSession();
  const headers = new Headers();
  headers.set("Content-Type", "application/json");
  if (session?.access_token) headers.set("Authorization", `Bearer ${session.access_token}`);
  return headers;
}

export async function apiGet<T>(path: string): Promise<T> {
  const headers = await getAuthHeaders();
  const res = await fetch(`${API_BASE}${path}`, { headers });
  if (!res.ok) throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`);
  return res.json() as Promise<T>;
}

export async function apiSend<T>(path: string, method: "POST" | "PUT" | "PATCH" | "DELETE", body?: unknown): Promise<T> {
  const headers = await getAuthHeaders();
  const res = await fetch(`${API_BASE}${path}`, {
    method,
    headers,
    body: body ? JSON.stringify(body) : undefined,
  });
  if (!res.ok) throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`);
  return res.json() as Promise<T>;
}


â¸»

2) Create resource service modules

Create file: client/src/services/briefs.ts

import { apiGet, apiSend } from "./http";
import type { Database } from "@shared/database.types";

type Brief = Database["public"]["Tables"]["dsd_briefs"]["Row"];
type BriefInsert = Database["public"]["Tables"]["dsd_briefs"]["Insert"];
type BriefUpdate = Database["public"]["Tables"]["dsd_briefs"]["Update"];

export async function listBriefs(params?: { projectId?: string }) {
  const q = params?.projectId ? `?projectId=${encodeURIComponent(params.projectId)}` : "";
  return apiGet<Brief[]>(`/briefs${q}`);
}

export async function createBrief(payload: BriefInsert) {
  return apiSend<Brief>("/briefs", "POST", payload);
}

export async function updateBrief(id: string, payload: BriefUpdate) {
  return apiSend<Brief>(`/briefs/${id}`, "PUT", payload);
}

export async function deleteBrief(id: string) {
  return apiSend<{ id: string }>(`/briefs/${id}`, "DELETE");
}

Create file: client/src/services/captures.ts

import { apiGet, apiSend } from "./http";
import type { Database } from "@shared/database.types";

type Capture = Database["public"]["Tables"]["captures"]["Row"];
type CaptureInsert = Database["public"]["Tables"]["captures"]["Insert"];
type CaptureUpdate = Database["public"]["Tables"]["captures"]["Update"];

export async function listCaptures(params?: {
  projectId?: string;
  status?: string;
  platform?: string;
  tag?: string;
  search?: string;
  page?: number;
  pageSize?: number;
}) {
  const qp = new URLSearchParams();
  Object.entries(params || {}).forEach(([k, v]) => {
    if (v !== undefined && v !== null && `${v}` !== "") qp.set(k, String(v));
  });
  const q = qp.toString() ? `?${qp.toString()}` : "";
  return apiGet<{ items: Capture[]; total: number }>(`/captures${q}`);
}

export async function createCapture(payload: CaptureInsert) {
  return apiSend<Capture>("/captures", "POST", payload);
}

export async function updateCapture(id: string, payload: CaptureUpdate) {
  return apiSend<Capture>(`/captures/${id}`, "PATCH", payload);
}

export async function deleteCapture(id: string) {
  return apiSend<{ id: string }>(`/captures/${id}`, "DELETE");
}

Create file: client/src/services/moments.ts

import { apiGet, apiSend } from "./http";
import type { Database } from "@shared/database.types";

type Moment = Database["public"]["Tables"]["cultural_moments"]["Row"];
type MomentInsert = Database["public"]["Tables"]["cultural_moments"]["Insert"];
type MomentUpdate = Database["public"]["Tables"]["cultural_moments"]["Update"];

export async function listMoments(params?: { projectId?: string }) {
  const q = params?.projectId ? `?projectId=${encodeURIComponent(params.projectId)}` : "";
  return apiGet<Moment[]>(`/moments${q}`);
}

export async function createMoment(payload: MomentInsert) {
  return apiSend<Moment>("/moments", "POST", payload);
}

export async function updateMoment(id: string, payload: MomentUpdate) {
  return apiSend<Moment>(`/moments/${id}`, "PATCH", payload);
}

export async function deleteMoment(id: string) {
  return apiSend<{ id: string }>(`/moments/${id}`, "DELETE");
}

Replace file: client/src/services/feeds.ts (migrate away from Supabase direct)

import { apiGet, apiSend } from "./http";
import type { Database } from "@shared/database.types";

type UserFeed = Database["public"]["Tables"]["user_feeds"]["Row"];
type UserFeedInsert = Database["public"]["Tables"]["user_feeds"]["Insert"];
type UserFeedUpdate = Database["public"]["Tables"]["user_feeds"]["Update"];

export async function listUserFeeds(params?: { projectId?: string }) {
  const q = params?.projectId ? `?projectId=${encodeURIComponent(params.projectId)}` : "";
  return apiGet<UserFeed[]>(`/feeds${q}`);
}

export async function createUserFeed(payload: UserFeedInsert) {
  return apiSend<UserFeed>("/feeds", "POST", payload);
}

export async function toggleUserFeedActive(id: string, is_active: boolean) {
  return apiSend<UserFeed>(`/feeds/${id}`, "PATCH", { is_active });
}

export async function deleteUserFeed(id: string) {
  return apiSend<{ id: string }>(`/feeds/${id}`, "DELETE");
}


â¸»

3) Refactor hooks to use services (remove Supabase client usage)

Edit: client/src/hooks/useBriefs.ts
	â€¢	Replace any supabase.from("dsd_briefs")... with calls to listBriefs, createBrief, updateBrief, deleteBrief from client/src/services/briefs.ts.
	â€¢	Keep React Query patterns the same (queries/mutations).
	â€¢	Remove supabase import if present.

Edit: client/src/hooks/useCaptures.ts
Use listCaptures, createCapture, updateCapture, deleteCapture.

Edit: client/src/hooks/useMoments.ts
Use listMoments, createMoment, updateMoment, deleteMoment.

Edit: client/src/services/feeds.ts
You already replaced it in step 2.

Tip: If those hooks expect slightly different shapes (e.g., pagination for captures), adapt the hook to the service return: items + total. Keep the hook API stable for the rest of the UI.

â¸»

4) Optional: Realtime invalidation

If youâ€™re still using Supabase Realtime to listen for table changes, keep that file (e.g., client/src/services/supabase-realtime.ts) but only to call queryClient.invalidateQueries(...) on events. The source of truth fetch remains your API services.

â¸»

5) Verify/patch server routes if missing

If any route from step 0 is missing, add minimal Express handlers.
	â€¢	Router file (example path): server/routes/api.ts (or update your existing):

import { Router } from "express";
import { requireAuth } from "../middleware/auth"; // your JWT/Supabase auth check
import * as Briefs from "../controllers/briefs";
import * as Captures from "../controllers/captures";
import * as Moments from "../controllers/moments";
import * as Feeds from "../controllers/feeds";

export const api = Router();
api.use(requireAuth);

// Briefs
api.get("/briefs", Briefs.list);
api.post("/briefs", Briefs.create);
api.put("/briefs/:id", Briefs.update);
api.delete("/briefs/:id", Briefs.remove);

// Captures
api.get("/captures", Captures.list);
api.post("/captures", Captures.create);
api.patch("/captures/:id", Captures.update);
api.delete("/captures/:id", Captures.remove);

// Moments
api.get("/moments", Moments.list);
api.post("/moments", Moments.create);
api.patch("/moments/:id", Moments.update);
api.delete("/moments/:id", Moments.remove);

// Feeds (user_feeds)
api.get("/feeds", Feeds.list);
api.post("/feeds", Feeds.create);
api.patch("/feeds/:id", Feeds.update);
api.delete("/feeds/:id", Feeds.remove);

	â€¢	Controller stubs should call your existing service/ORM (Drizzle/queries). If these already exist, just confirm paths match the client calls.

HUMAN PAUSE #1:
Confirm all endpoints exist and return JSON with shapes expected in step 2 (especially captures pagination: { items, total }). If mismatched, adjust either the controller or the client service accordingly. Then continue.

â¸»

6) Clean imports & run checks
	â€¢	Remove any leftover import { supabase } from ... from the 4 files.
	â€¢	Ensure all imports now reference the new services:

import { listBriefs, createBrief, updateBrief, deleteBrief } from "@/services/briefs";
import { listCaptures, createCapture, updateCapture, deleteCapture } from "@/services/captures";
import { listMoments, createMoment, updateMoment, deleteMoment } from "@/services/moments";
import { listUserFeeds, createUserFeed, toggleUserFeedActive, deleteUserFeed } from "@/services/feeds";

	â€¢	Run:
	â€¢	npm run typecheck
	â€¢	npm run build

HUMAN PAUSE #2:
If either fails, print the exact errors and stop for guidance.

â¸»

7) Smoke test
	â€¢	Start the full stack.
	â€¢	Navigate through:
	â€¢	Briefs list/create/edit/delete
	â€¢	Captures list with filters, create/edit/delete
	â€¢	Moments list/create/edit/delete
	â€¢	Feeds list/create/toggle/delete
	â€¢	Confirm:
	â€¢	No direct Supabase reads/writes in those 4 files (only API calls).
	â€¢	Auth headers are present (Bearer JWT) on API requests.
	â€¢	Realtime (if enabled) invalidates the relevant React Query caches.

â¸»

8) Commit

git add .
git commit -m "chore: route remaining client data flows through API (remove direct Supabase calls in hooks/services)"
git push


â¸»

Notes & gotchas
	â€¢	Why this change? Single ingress (your API) concentrates auth, RLS, validation, and caching. Direct clientâ†’Supabase reads were the last source of drift.
	â€¢	Performance: On heavy lists (captures), keep pagination server-side (already reflected in the service). You can layer React Query caching on the client.
	â€¢	Security: Supabase JWT goes to your server only. The server uses service role/admin or RLS-safe queries; the client never touches DB directly now.

â¸»

If you want, I can also give you tiny sed one-liners to strip the supabase imports from those exact files, but the service swap above is the correct, future-proof approach.