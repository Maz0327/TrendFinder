2) client/src/components/dashboard/Sidebar.tsx
You’re calling .text() on an object { url: string }.

Edit

ts
Copy
Edit
// BEFORE
const data = await response.text();
// AFTER
const data = (response as { url: string }).url;
(Or, if this code actually wants the full file content, change the API call to return a string and keep the above as const data = response as string;)

3) client/src/components/dashboard/TrendModal.tsx
Your mutation returns string[], but code expects { hooks: string[] }.

Edits

Make the mutation’s return type { hooks: string[] }, and then use it consistently:

ts
Copy
Edit
// mutation
mutationFn: (id: string) => api.post<{ hooks: string[] }>(`/api/trends/${id}/generate-hooks`),

// onSuccess
setAdditionalHooks(data.hooks);
toast({ description: `Generated ${data.hooks.length} additional hooks` });
If your endpoint really returns string[], then change the 2 call sites instead:

ts
Copy
Edit
setAdditionalHooks(data);
toast({ description: `Generated ${data.length} additional hooks` });
4) client/src/pages/analysis.tsx
Type the request and state.

Edits

ts
Copy
Edit
// make the API call typed
const { mutateAsync: analyze } = useMutation({
  mutationFn: (payload: AnalyzePayload) =>
    api.post<TruthAnalysis>('/api/truth-analysis/analyze', payload),
  onSuccess: (data) => setAnalysisResult(data),
});
5) client/src/pages/brief-builder.tsx
selectedProject is a string, not an object.

Edit

tsx
Copy
Edit
// BEFORE
projectId={selectedProject?.id || ''}
// AFTER (if selectedProject is an id string)
projectId={selectedProject || ''}
// OR type selectedProject as Project and keep .id
6) client/src/pages/capture-tagging-enhanced.tsx
Make platforms a string[] so .map((platform: string) => ...) matches.

Edit (near where platforms is defined)

ts
Copy
Edit
const platforms = (someSource as unknown[]).filter(Boolean).map(String) as string[];
or ensure the query is typed:

ts
Copy
Edit
const { data: platforms = [] } = useQuery<string[]>({ /* ... */ });
7) client/src/components/dashboard/StatsOverview.tsx + client/src/pages/dashboard.tsx
You have two different DashboardStats types. Centralize it.

Steps

Create client/src/types/dashboard.ts:

ts
Copy
Edit
export type DashboardStats = {
  totalTrends: number;
  viralPotential: number;
  activeSources: number;
  avgScore: number;
  // add any shared, agreed fields only here
};
In both files, replace any local type DashboardStats with:

ts
Copy
Edit
import type { DashboardStats } from '@/types/dashboard';
8) client/src/pages/intelligence.tsx
Type the response and defaults.

At top

ts
Copy
Edit
type IntelligenceSummary = {
  totalSignals: number;
  tier1Signals: number;
  tier2Signals: number;
  trends: number;
};
Where the query/mutation runs

ts
Copy
Edit
const fetchIntelligence = useQuery({
  queryKey: ['intelligence'],
  queryFn: () => api.get<IntelligenceSummary>('/api/intelligence/summary'),
});

// When reading:
fetchIntelligence.data?.totalSignals ?? 0
fetchIntelligence.data?.tier1Signals ?? 0
fetchIntelligence.data?.tier2Signals ?? 0
fetchIntelligence.data?.trends ?? 0
In toast

ts
Copy
Edit
description: `Collected ${data.totalSignals} signals across ${data.tier1Signals + data.tier2Signals} sources`,
(works because data is now typed)

9) client/src/pages/login.tsx and client/src/pages/register.tsx
Remove setUser if your auth context doesn’t expose it.

Edit

ts
Copy
Edit
// BEFORE
const { setUser } = useAuth();
// AFTER
const { user, isLoading, isAuthenticated, logout } = useAuth();
…and delete usages of setUser in those files.

10) Projects/Collections used in several pages
For every page that maps projects/captures/analyses, type the query and default to [].

Pattern (apply in these files):

client/src/pages/lovable-capture.tsx

client/src/pages/manage.tsx

client/src/pages/my-captures.tsx

client/src/pages/signal-capture.tsx

client/src/pages/truth-analysis.tsx

ts
Copy
Edit
const { data: projects = [] } = useQuery<Project[]>({
  queryKey: ['projects'],
  queryFn: () => api.get<Project[]>('/api/projects'),
});
Do the same for captures: Capture[], analyses: TruthAnalysis[].

Also fix my-captures.tsx where Project lacks title:

Either add title?: string to Project type,

Or render a safe value:

tsx
Copy
Edit
{project.title ?? project.name ?? 'Untitled'}
11) client/src/pages/new-dashboard.tsx
Pass required title:

tsx
Copy
Edit
<TrendChart title="Capture trend" data={chartData} />
12) client/src/pages/settings.tsx
Make types match usage.

Edits

BrightDataStatus should include optional platforms:

ts
Copy
Edit
type BrightDataStatus = {
  connected: boolean;
  // ...
  platforms?: Record<string, any>;
};
Instructions should include steps:

ts
Copy
Edit
type Instructions = {
  steps?: string[];
  // ...
};
Server-side fixes
13) server/middleware/auth.ts
Align email optionality with what you set on req.user.

Edit

ts
Copy
Edit
export interface AuthedUser {
  id: string;
  email?: string;  // <- optional to match creation
  role?: string;
  metadata?: any;
}
export interface AuthedRequest extends Request {
  user?: AuthedUser;
}
14) server/routes/google-exports.ts
a) brief.content not present → build the DTO from available fields.
b) Match service input types exactly.
c) Remove lastAnalyzed.
d) Map service results to { id, title }.
e) Guard imageData.

Minimal patch (edit the section building briefData, service calls, and response):

ts
Copy
Edit
const briefData = {
  title: brief.title,
  content: brief.content ?? { define: [], shift: [], deliver: [] },
  // if you only have defineContent/shiftContent/deliverContent, map them here:
  // content: {
  //   define: brief.defineContent?.define ?? [],
  //   shift:  brief.defineContent?.shift ?? [],
  //   deliver: brief.defineContent?.deliver ?? [],
  // },
  captures: (captures ?? []).map(c => ({
    title: c.title ?? '',
    content: c.content ?? '',
    truthAnalysis: c.truthAnalysis ? {
      fact: c.truthAnalysis.fact,
      observation: c.truthAnalysis.observation,
      insight: c.truthAnalysis.insight,
      humanTruth: c.truthAnalysis.humanTruth,
      strategicValue: c.truthAnalysis.strategicValue ?? 0,
      viralPotential: c.truthAnalysis.viralPotential ?? 0,
      keywords: c.truthAnalysis.keywords ?? [],
      // add confidence if your service expects it
      confidence: (c.truthAnalysis as any)?.confidence ?? 0,
    } : undefined,
    // visualAnalysis if your service expects it
  })),
} as const;

// service result id mapping
const slidesRaw = await slidesService.createPresentationFromBrief(briefData);
const docsRaw   = await docsService.createDetailedBriefDocument(briefData);
const sheetsRaw = await sheetsService.createAnalysisSpreadsheet(briefData);

const slidesResult = { id: slidesRaw.presentationId, title: slidesRaw.title };
const docsResult   = { id: docsRaw.documentId,       title: docsRaw.title };
const sheetsResult = { id: sheetsRaw.spreadsheetId,  title: sheetsRaw.title };

// imageData guards
const capturesWithImages = (captures ?? []).filter((c: any) => c.type === 'image' && (c as any).imageData);
await someServiceThatNeedsImages(capturesWithImages as Array<{ title: string; content: string; type: string; imageData?: string }>);

// when updating DB object, remove `lastAnalyzed` OR add it to your storage type
// await storage.updateCapture(id, { lastAnalyzed: new Date().toISOString() }); // <- remove this if not in type

res.json({ slides: slidesResult, docs: docsResult, sheets: sheetsResult });
Also fix project.definePoints/shiftPoints/deliverPoints:

ts
Copy
Edit
define: (project as any).definePoints ?? [],
shift:  (project as any).shiftPoints ?? [],
deliver:(project as any).deliverPoints ?? [],
15) server/routes/projects.ts
content can be null.

Edit

ts
Copy
Edit
content: capture.content ?? '',
16) server/services/brightDataBrowser.ts
Give arrays types.

Cast anchor elements before reading .href.

Edits

ts
Copy
Edit
const extractedPosts: Array<{ url: string; /* … */ }> = [];
const extractedVideos: Array<{ url: string; /* … */ }> = [];
const extractedTweets: Array<{ url: string; /* … */ }> = [];

// when reading href on generic Element:
const linkElement = el.querySelector('a');
const url = (linkElement as HTMLAnchorElement | null)?.href
  ?? linkElement?.getAttribute('href')
  ?? '';
(Apply the same pattern at every place complaining about .href.)

17) server/services/capture-analysis-service.ts
Your storage expects a nested object; you’re assigning a different DTO.

Either change the storage type to accept your TruthAnalysisResult
or map it:

ts
Copy
Edit
updates.truthAnalysis = {
  fact: {
    claims: analysisResult.truthAnalysis.claims,
    sources: analysisResult.truthAnalysis.sources,
    verificationStatus: analysisResult.truthAnalysis.verificationStatus,
    confidence: analysisResult.truthAnalysis.confidence,
  },
  observation: { /* map fields */ },
  insight: { /* map fields */ },
  humanTruth: { /* map fields */ },
};

// visualAnalysis expected as string; stringify or change type
updates.visualAnalysis = JSON.stringify(analysisResult.visualAnalysis);
Also fix metadata type:

ts
Copy
Edit
updates.metadata = updates.metadata as Json | undefined;
18) server/services/chromeExtensionService.ts
Add index signatures.

ts
Copy
Edit
const platformMultipliers: Record<string, number> = { twitter: 1.2, tiktok: 1.3, instagram: 1.1, linkedin: 1.0, youtube: 1.15, reddit: 1.05, web: 1.0 };
score *= platformMultipliers[content.platform || 'web'] || 1.0;

const platformWeights: Record<string, number> = { twitter: 60, tiktok: 70, instagram: 55, linkedin: 45, reddit: 50 };
const platformWeight = platformWeights[content.platform || 'twitter'] || 50;
Wrap unknown error:

ts
Copy
Edit
} catch (error) {
  const msg = (error as Error)?.message ?? String(error);
  throw new Error(`Failed to process captured content: ${msg}`);
}
19) server/services/google-bigquery-service.ts
Type results.

ts
Copy
Edit
const results: Record<string, any[]> = {};
results[key] = rows as any[];
20) server/services/google-custom-search-service.ts
Index signatures + array type.

ts
Copy
Edit
const siteMap: Record<string, string> = { reddit: 'site:reddit.com', twitter: 'site:twitter.com', tiktok: 'site:tiktok.com', instagram: 'site:instagram.com', youtube: 'site:youtube.com', linkedin: 'site:linkedin.com' };

if (options.platform && siteMap[options.platform]) {
  searchParams.q += ` ${siteMap[options.platform]}`;
}

intelligence.campaignInsights = intelligence.campaignInsights ?? [] as Array<{ title: string; url: string; platform: string; insights: string[] }>;
intelligence.campaignInsights.push({ title: result.title, url: result.link, platform: options.platform ?? 'web', insights: this.extractCampaignInsights(result.snippet) });
21) server/services/google-nlp-service.ts and server/services/google-vision-service.ts
Initialize arrays as string[], not never[]. Allow safety analysis to be an object.

ts
Copy
Edit
analysis.strategicInsights = [] as string[];
analysis.strategicInsights = this.generateNLPInsights(analysis); // returns string[]

analysis.safetyAnalysis = {
  adult: x, violence: y, racy: z, medical: a, spoof: b,
};
analysis.strategicInsights = this.generateStrategicInsights(analysis); // returns string[]
22) server/services/liveBrightDataService.ts
Remove unsupported ignoreHTTPSErrors.

Type limit params.

Type local arrays.

Cast .href access.

Edits

ts
Copy
Edit
connect({
  // remove ignoreHTTPSErrors
});

const posts = await page.evaluate((limit: number) => { /* ... */ });
let foundElements: Element[] = [];
const element = foundElements[i] as HTMLElement;

// repeat for tweets/posts/videos
const tweets = await page.evaluate((limit: number) => { /* ... */ });

url: (video as HTMLAnchorElement | any)?.href || window.location.href,
23) vite.config.ts
ts
Copy
Edit
server: {
  allowedHosts: true, // not "all"
},