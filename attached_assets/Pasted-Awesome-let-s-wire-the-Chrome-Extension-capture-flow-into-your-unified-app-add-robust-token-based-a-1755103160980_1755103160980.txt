Awesome—let’s wire the Chrome Extension capture flow into your unified app, add robust token-based auth, store screenshots + metadata, and make sure tags are first-class. Below is a single Replit Task Runbook you can paste into Replit’s “Tasks”. It includes clear HUMAN STOP checkpoints where you do small manual actions (Supabase dashboard, Chrome install, etc.). Everything else the agent can do.

⸻

✅ Replit Task Runbook — “Chrome Extension v1 + Unified Backend + Tags”

Goals
	•	Add DB columns for screenshots/metadata, token tables, and a small analysis job queue.
	•	Create secure extension tokens (user-scoped, revocable) and /api/extension/* endpoints.
	•	Upload PNGs to Supabase Storage via the server using the service role (not from the extension).
	•	Ensure tags are honored end-to-end and provide a simple tag aggregation API.
	•	Scaffold a working Chrome Extension (Manifest V3): overlay region selector → PNG crop → metadata → upload.
	•	Add a simple Settings → Extensions page to manage tokens.
	•	Keep everything in one app (no second frontend), aligned with the consolidated architecture.

⸻

Task 0 — Preflight
	1.	Check env vars exist:

	•	VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY (client)
	•	SUPABASE_SERVICE_ROLE_KEY (server) – required for Storage + DB writes on behalf of user
	•	SUPABASE_URL (server) – base URL, typically same as VITE one
	•	SITE_URL – your app public URL (for CORS, optional)

If any are missing, pause and ask the human.

⸻

Task 1 — Database migration (captures extras, tokens, jobs, indexes)

Create migration file supabase/migrations/2025-08-14-extension-captures.sql with:

-- 1) Extra capture fields for screenshots + analysis state
alter table public.captures
  add column if not exists project_id uuid references public.projects(id) on delete set null,
  add column if not exists image_url text,
  add column if not exists image_thumb_url text,
  add column if not exists selection_rect jsonb,
  add column if not exists ocr_text text,
  add column if not exists source_author text,
  add column if not exists source_posted_at timestamptz,
  add column if not exists source_metrics jsonb,
  add column if not exists analysis_status text check (analysis_status in ('pending','complete','failed')) default null,
  add column if not exists analysis_run_id text;

-- 2) Make tags efficient (already text[]); add GIN index for tag filtering
create index if not exists idx_captures_tags_gin on public.captures using gin (tags);

-- 3) Token table for Chrome extension (user-scoped, hash stored)
create table if not exists public.extension_tokens (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  name text not null,
  token_hash text not null,
  created_at timestamptz not null default now(),
  last_used_at timestamptz,
  revoked boolean not null default false
);
alter table public.extension_tokens enable row level security;

drop policy if exists ext_tok_select on public.extension_tokens;
drop policy if exists ext_tok_all on public.extension_tokens;

create policy ext_tok_select on public.extension_tokens
  for select
  using (auth.uid() = user_id);

create policy ext_tok_all on public.extension_tokens
  for all
  using (auth.uid() = user_id);

-- 4) Lightweight job table for Truth Analysis handoff
create table if not exists public.analysis_jobs (
  id uuid primary key default gen_random_uuid(),
  capture_id uuid not null references public.captures(id) on delete cascade,
  status text not null check (status in ('queued','running','complete','failed')),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
alter table public.analysis_jobs enable row level security;

drop policy if exists analysis_jobs_owner on public.analysis_jobs;
create policy analysis_jobs_owner on public.analysis_jobs
  for select
  using (exists (
    select 1 from public.captures c 
    where c.id = analysis_jobs.capture_id and c.user_id = auth.uid()
  ));

-- 5) Storage bucket: create if missing (via SQL)
insert into storage.buckets (id, name, public)
select 'captures', 'captures', false
where not exists (select 1 from storage.buckets where id='captures');

Apply migration:
	•	If you have a migration runner, use it; otherwise copy/paste the SQL into Supabase SQL Editor and run.

HUMAN STOP A:
Open Supabase → Storage → captures bucket → Policies and add:
	•	Read: authenticated users can read only objects that start with their own user id (captures/{user_id}/*).
	•	Write: deny direct client write (we write via server).
(If you prefer client-side write later, we can add a restricted client policy.)

⸻

Task 2 — Types update

Open shared/database.types.ts and ensure the new fields/tables exist:
	•	In public.Tables.captures.Row add the new columns from Task 1 (all optional).
	•	Create public.Tables.extension_tokens with Row/Insert/Update.
	•	Create public.Tables.analysis_jobs with Row/Insert/Update.

Run:

npm run typecheck

Fix any import paths if necessary.

⸻

Task 3 — Server: Supabase Admin client + CORS
	1.	Create server/lib/supabaseAdmin.ts:

import { createClient } from '@supabase/supabase-js';

const SUPABASE_URL = process.env.SUPABASE_URL!;
const SERVICE_ROLE = process.env.SUPABASE_SERVICE_ROLE_KEY!;

export const supabaseAdmin = createClient(SUPABASE_URL, SERVICE_ROLE, {
  auth: { persistSession: false }
});

	2.	Ensure CORS allows extension uploads. In your Express bootstrap (e.g., server/index.ts or server/app.ts), add:

import cors from 'cors';

const ALLOWED_ORIGINS = [
  process.env.SITE_URL || '',
  // allow Replit preview and localhost
  'http://localhost:5173',
  'http://localhost:3000'
  // For dev: we’ll allow "*" on /api/extension/upload only below
];

app.use(cors({
  origin: (origin, cb) => {
    if (!origin) return cb(null, true);
    if (ALLOWED_ORIGINS.some(o => origin.startsWith(o))) return cb(null, true);
    // fail closed by default
    return cb(null, false);
  },
  credentials: true
}));

We’ll override CORS to * on the specific upload route to simplify extension dev.

Install deps if missing:

npm i @supabase/supabase-js bcryptjs zod cors


⸻

Task 4 — Server: extension routes + token helpers

Create server/routes/extension.ts:

import { Router } from 'express';
import { supabaseAdmin } from '../lib/supabaseAdmin';
import { z } from 'zod';
import bcrypt from 'bcryptjs';
import crypto from 'crypto';
import type { Database } from '../../shared/database.types';

const router = Router();

// --------- Helpers ----------
async function hashToken(token: string) {
  const salt = await bcrypt.genSalt(10);
  return bcrypt.hash(token, salt);
}

function generateToken(): string {
  // 48 bytes -> 64 char base64url string
  return crypto.randomBytes(48).toString('base64url');
}

// Validate and look up token -> user_id
async function getUserIdFromToken(tokenPlain: string) {
  const { data, error } = await supabaseAdmin
    .from('extension_tokens')
    .select('id, user_id, token_hash, revoked')
    .eq('revoked', false);

  if (error || !data) return null;

  for (const row of data) {
    const ok = await bcrypt.compare(tokenPlain, row.token_hash);
    if (ok) {
      // Update last_used_at
      await supabaseAdmin.from('extension_tokens')
        .update({ last_used_at: new Date().toISOString() })
        .eq('id', row.id);
      return row.user_id as string;
    }
  }
  return null;
}

// --------- Schemas ----------
const uploadSchema = z.object({
  token: z.string().optional(), // or Authorization header
  projectId: z.string().uuid().nullable().optional(),
  url: z.string().url(),
  title: z.string().optional(),
  platform: z.string().nullable().optional(),
  notes: z.string().nullable().optional(),
  tags: z.array(z.string()).optional().default([]),
  imageDataUrl: z.string().startsWith('data:image/'),
  selectionRect: z.object({
    x: z.number(), y: z.number(), width: z.number(), height: z.number(), dpr: z.number()
  }).optional(),
  ocrText: z.string().optional(),
  source: z.object({
    author: z.string().nullable().optional(),
    postedAt: z.string().transform(v => new Date(v).toISOString()).nullable().optional(),
    metrics: z.record(z.any()).optional()
  }).optional(),
  queueAnalysis: z.boolean().optional().default(false)
});

// --------- Routes (user-auth pages to manage tokens) ----------
// Requires cookie auth (your existing auth middleware)
router.post('/tokens', async (req: any, res) => {
  try {
    const user = req.user; // assume your auth middleware adds req.user
    if (!user?.id) return res.status(401).json({ error: 'unauthorized' });

    const name = (req.body?.name || '').toString().trim() || 'My Extension';
    const tokenPlain = generateToken();
    const token_hash = await hashToken(tokenPlain);

    const { error, data } = await supabaseAdmin
      .from('extension_tokens')
      .insert({ user_id: user.id, name, token_hash })
      .select('id, name, created_at')
      .single();

    if (error) return res.status(500).json({ error: error.message });

    // Return plaintext once
    res.json({ token: tokenPlain, info: data });
  } catch (e: any) {
    res.status(500).json({ error: e?.message || 'failed' });
  }
});

router.get('/tokens', async (req: any, res) => {
  try {
    const user = req.user;
    if (!user?.id) return res.status(401).json({ error: 'unauthorized' });

    const { data, error } = await supabaseAdmin
      .from('extension_tokens')
      .select('id, name, created_at, last_used_at, revoked')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });

    if (error) return res.status(500).json({ error: error.message });
    res.json({ tokens: data });
  } catch (e: any) {
    res.status(500).json({ error: e?.message || 'failed' });
  }
});

router.post('/tokens/:id/revoke', async (req: any, res) => {
  try {
    const user = req.user;
    if (!user?.id) return res.status(401).json({ error: 'unauthorized' });

    const { id } = req.params;
    const { data: rows, error: selErr } = await supabaseAdmin
      .from('extension_tokens').select('user_id').eq('id', id).single();

    if (selErr || !rows) return res.status(404).json({ error: 'not found' });
    if (rows.user_id !== user.id) return res.status(403).json({ error: 'forbidden' });

    const { error } = await supabaseAdmin
      .from('extension_tokens').update({ revoked: true }).eq('id', id);

    if (error) return res.status(500).json({ error: error.message });
    res.json({ ok: true });
  } catch (e: any) {
    res.status(500).json({ error: e?.message || 'failed' });
  }
});

// --------- Routes for the Extension (token header, CORS: *) ----------
router.post('/upload', async (req, res, next) => {
  // allow the extension in dev from anywhere
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  if (req.method === 'OPTIONS') return res.sendStatus(200);
  next();
}, async (req, res) => {
  try {
    const authHeader = req.headers.authorization || '';
    const bearer = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : undefined;
    const body = uploadSchema.parse({ ...req.body, token: req.body?.token || bearer });

    if (!body.token) return res.status(401).json({ error: 'missing token' });
    const userId = await getUserIdFromToken(body.token);
    if (!userId) return res.status(401).json({ error: 'invalid token' });

    // decode dataURL
    const match = body.imageDataUrl.match(/^data:(image\/\w+);base64,(.+)$/);
    if (!match) return res.status(400).json({ error: 'invalid image' });
    const ext = match[1].split('/')[1];
    const buf = Buffer.from(match[2], 'base64');

    // upload to storage
    const captureId = crypto.randomUUID();
    const key = `captures/${userId}/${captureId}.${ext}`;

    const up = await supabaseAdmin.storage.from('captures').upload(key, buf, {
      contentType: match[1],
      upsert: false
    });
    if (up.error) return res.status(500).json({ error: up.error.message });

    const publicUrl = supabaseAdmin.storage.from('captures').getPublicUrl(key).data.publicUrl ?? null;

    // insert capture row
    const insertPayload: Partial<Database['public']['Tables']['captures']['Insert']> = {
      id: captureId,
      user_id: userId,
      title: body.title || null,
      content: body.notes || '',    // store notes in content initially
      platform: body.platform || null,
      url: body.url,
      tags: body.tags?.length ? body.tags : [],
      ai_analysis: null,
      project_id: body.projectId || null,
      image_url: key,
      selection_rect: body.selectionRect || null,
      ocr_text: body.ocrText || null,
      source_author: body.source?.author || null,
      source_posted_at: body.source?.postedAt ? new Date(body.source.postedAt).toISOString() : null,
      source_metrics: body.source?.metrics || null,
      analysis_status: body.queueAnalysis ? 'pending' : null
    };

    const { data: cap, error: capErr } = await supabaseAdmin
      .from('captures')
      .insert(insertPayload)
      .select('*').single();

    if (capErr) return res.status(500).json({ error: capErr.message });

    // queue analysis job if requested
    if (body.queueAnalysis) {
      await supabaseAdmin.from('analysis_jobs')
        .insert({ capture_id: captureId, status: 'queued' });
    }

    res.json({ capture: cap, imagePublicUrl: publicUrl });
  } catch (e: any) {
    res.status(500).json({ error: e?.message || 'failed' });
  }
});

// Optional: projects for extension quick picker (by token)
router.get('/projects', async (req, res) => {
  res.header('Access-Control-Allow-Origin', '*');
  try {
    const bearer = (req.headers.authorization || '').replace('Bearer ', '');
    if (!bearer) return res.status(401).json({ error: 'missing token' });
    const userId = await getUserIdFromToken(bearer);
    if (!userId) return res.status(401).json({ error: 'invalid token' });

    const { data, error } = await supabaseAdmin
      .from('projects')
      .select('id, name, created_at')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) return res.status(500).json({ error: error.message });
    res.json({ projects: data || [] });
  } catch (e: any) {
    res.status(500).json({ error: e?.message || 'failed' });
  }
});

// Tag aggregation: return user's tags (optionally by project)
router.get('/tags', async (req, res) => {
  res.header('Access-Control-Allow-Origin', '*');
  try {
    const bearer = (req.headers.authorization || '').replace('Bearer ', '');
    if (!bearer) return res.status(401).json({ error: 'missing token' });
    const userId = await getUserIdFromToken(bearer);
    if (!userId) return res.status(401).json({ error: 'invalid token' });

    const projectId = (req.query.projectId || '').toString() || null;

    const { data, error } = await supabaseAdmin
      .from('captures')
      .select('tags')
      .eq('user_id', userId)
      .maybeSingle();

    // We need all rows, not single:
    const { data: rows, error: err2 } = await supabaseAdmin
      .from('captures')
      .select('tags')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (err2) return res.status(500).json({ error: err2.message });
    const freq: Record<string, number> = {};
    for (const r of rows || []) {
      if (!r.tags) continue;
      for (const t of r.tags) {
        const key = (t || '').trim();
        if (!key) continue;
        freq[key] = (freq[key] || 0) + 1;
      }
    }
    res.json({ tags: Object.entries(freq).map(([tag, count]) => ({ tag, count })) });
  } catch (e: any) {
    res.status(500).json({ error: e?.message || 'failed' });
  }
});

export default router;

	3.	Wire it up in your server entry (e.g., server/index.ts):

import extensionRoutes from './routes/extension';

// After app.use(express.json())
app.use('/api/extension', extensionRoutes);

Run:

npm run build && npm run start

(Or your project’s equivalent serve command.)

⸻

Task 5 — Client: Settings → Extensions (token UI)

Create client/src/pages/settings/Extensions.tsx:

import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';

type TokenRow = {
  id: string; name: string; created_at: string; last_used_at: string | null; revoked: boolean
};

export default function ExtensionsSettings() {
  const [tokens, setTokens] = useState<TokenRow[]>([]);
  const [name, setName] = useState('');
  const [newToken, setNewToken] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  async function refresh() {
    const r = await fetch('/api/extension/tokens', { credentials: 'include' });
    if (!r.ok) return;
    const json = await r.json();
    setTokens(json.tokens || []);
  }

  useEffect(() => { refresh(); }, []);

  async function createToken() {
    setLoading(true);
    setNewToken(null);
    const r = await fetch('/api/extension/tokens', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({ name: name || 'My Extension' })
    });
    setLoading(false);
    if (!r.ok) return;
    const json = await r.json();
    setNewToken(json.token);
    setName('');
    refresh();
  }

  async function revoke(id: string) {
    const r = await fetch(`/api/extension/tokens/${id}/revoke`, {
      method: 'POST', credentials: 'include'
    });
    if (r.ok) refresh();
  }

  return (
    <div className="max-w-2xl space-y-6">
      <h1 className="text-2xl font-semibold">Extension Access Tokens</h1>

      <div className="border rounded p-4 space-y-3">
        <div className="flex gap-2">
          <Input placeholder="Token name (e.g., Maz’s Laptop)" value={name} onChange={e => setName(e.target.value)} />
          <Button onClick={createToken} disabled={loading}>{loading ? 'Creating…' : 'Create Token'}</Button>
        </div>
        {newToken && (
          <div className="bg-muted/50 border rounded p-3">
            <div className="font-medium mb-1">Copy this token now (shown once):</div>
            <code className="break-all text-sm">{newToken}</code>
          </div>
        )}
      </div>

      <div className="border rounded">
        <div className="p-3 border-b font-medium">Your Tokens</div>
        <div className="divide-y">
          {tokens.map(t => (
            <div key={t.id} className="p-3 flex items-center justify-between">
              <div>
                <div className="font-medium">{t.name}{t.revoked ? ' (revoked)' : ''}</div>
                <div className="text-sm text-muted-foreground">
                  Created {new Date(t.created_at).toLocaleString()}
                  {t.last_used_at ? ` • Last used ${new Date(t.last_used_at).toLocaleString()}` : ''}
                </div>
              </div>
              {!t.revoked && <Button variant="outline" onClick={() => revoke(t.id)}>Revoke</Button>}
            </div>
          ))}
          {!tokens.length && <div className="p-3 text-sm text-muted-foreground">No tokens yet.</div>}
        </div>
      </div>
    </div>
  );
}

Add a route (where your router is defined) e.g., client/src/App.tsx:

// import ExtensionsSettings from '@/pages/settings/Extensions';
{ /* <Route path="/settings/extensions" element={<RequireAuth><ExtensionsSettings/></RequireAuth>} /> */ }

(Adjust import/RequireAuth according to your app.)

⸻

Task 6 — Chrome Extension scaffold

Create folder extension/ with files:

extension/manifest.json

{
  "manifest_version": 3,
  "name": "Content Radar Capture",
  "version": "0.1.0",
  "description": "Precision region capture + metadata → uploads to Content Radar",
  "permissions": ["activeTab", "scripting", "storage", "tabs"],
  "host_permissions": ["<all_urls>"],
  "background": { "service_worker": "background.js" },
  "action": { "default_popup": "popup.html", "default_title": "Capture" },
  "icons": { "16": "icons/16.png", "48": "icons/48.png", "128": "icons/128.png" },
  "options_page": "options.html",
  "content_scripts": [{
    "matches": ["<all_urls>"],
    "js": ["content.js"],
    "run_at": "document_end"
  }]
}

extension/popup.html

<!doctype html>
<html>
<head><meta charset="utf-8"><title>Capture</title>
<style>body{font:14px system-ui;padding:12px;min-width:320px}</style></head>
<body>
  <div>
    <label>Server URL <input id="serverUrl" placeholder="https://yourapp.com"></label>
  </div>
  <div>
    <label>Token <input id="token" placeholder="paste extension token"></label>
  </div>
  <div>
    <label>Project <select id="project"></select></label>
  </div>
  <div>
    <label>Tags (comma) <input id="tags" placeholder="trend, meme, competitor"></label>
  </div>
  <div>
    <label>Notes <textarea id="notes" rows="3"></textarea></label>
  </div>
  <div style="margin-top:8px;display:flex;gap:8px;">
    <button id="selectRegion">Select Region</button>
    <button id="upload" disabled>Upload</button>
  </div>
  <div id="status" style="margin-top:8px;color:#666"></div>
  <script src="popup.js"></script>
</body>
</html>

extension/options.html

<!doctype html>
<html>
<head><meta charset="utf-8"><title>Options</title></head>
<body>
  <h3>Content Radar Extension</h3>
  <label>Server URL <input id="serverUrl"></label>
  <label>Token <input id="token"></label>
  <button id="save">Save</button>
  <div id="msg"></div>
  <script>
    (async function(){
      const s = await chrome.storage.sync.get(['serverUrl','token']);
      document.getElementById('serverUrl').value = s.serverUrl || '';
      document.getElementById('token').value = s.token || '';
      document.getElementById('save').onclick = async () => {
        await chrome.storage.sync.set({
          serverUrl: document.getElementById('serverUrl').value.trim(),
          token: document.getElementById('token').value.trim()
        });
        document.getElementById('msg').textContent = 'Saved';
        setTimeout(()=>document.getElementById('msg').textContent='',1500);
      };
    })();
  </script>
</body>
</html>

extension/background.js

chrome.runtime.onInstalled.addListener(()=>{ /* init */ });

// Simple retry queue (very basic)
const queueKey = 'uploadQueue';

async function pushQueue(item){
  const s = await chrome.storage.local.get([queueKey]);
  const q = s[queueKey] || [];
  q.push({...item, attempts:(item.attempts||0)});
  await chrome.storage.local.set({[queueKey]: q});
}

async function processQueue(){
  const s = await chrome.storage.local.get([queueKey,'serverUrl','token']);
  const q = s[queueKey] || [];
  const serverUrl = s.serverUrl;
  const token = s.token;
  if (!serverUrl || !token || !q.length) return;

  const remain = [];
  for (const item of q) {
    try {
      const r = await fetch(`${serverUrl}/api/extension/upload`, {
        method: 'POST',
        headers: {'Content-Type':'application/json', 'Authorization': `Bearer ${token}`},
        body: JSON.stringify(item.payload)
      });
      if (!r.ok) throw new Error('upload failed');
      // ok
    } catch(e){
      const a = (item.attempts||0)+1;
      if (a < 5) remain.push({...item, attempts:a});
    }
  }
  await chrome.storage.local.set({[queueKey]: remain});
}

setInterval(processQueue, 10000);

extension/content.js

// Inject a simple selection overlay when asked by popup
let overlay;
let selection = null;

function createOverlay() {
  overlay = document.createElement('div');
  overlay.style.cssText = `
    position:fixed;inset:0; background:rgba(0,0,0,.12); z-index:2147483647; cursor:crosshair;
  `;
  document.body.appendChild(overlay);

  const box = document.createElement('div');
  box.style.cssText = `position:absolute;border:2px solid #4DA3FF;background:rgba(77,163,255,.15)`;
  overlay.appendChild(box);

  let startX=0, startY=0;
  function onDown(e){ startX=e.clientX; startY=e.clientY; selection={x:startX,y:startY,w:0,h:0}; updateBox(); overlay.addEventListener('mousemove',onMove); }
  function onMove(e){
    selection.w = Math.abs(e.clientX - startX);
    selection.h = Math.abs(e.clientY - startY);
    selection.x = Math.min(e.clientX, startX);
    selection.y = Math.min(e.clientY, startY);
    updateBox();
  }
  function onUp(){
    overlay.removeEventListener('mousemove',onMove);
    chrome.runtime.sendMessage({type:'selection-complete', rect:selection, dpr:window.devicePixelRatio, url:location.href, title:document.title});
    destroy();
  }
  function updateBox(){
    box.style.left = selection.x+'px';
    box.style.top = selection.y+'px';
    box.style.width = selection.w+'px';
    box.style.height = selection.h+'px';
  }
  function destroy(){
    overlay.removeEventListener('mousedown',onDown);
    overlay.removeEventListener('mouseup',onUp);
    overlay.remove();
    overlay = null;
  }
  overlay.addEventListener('mousedown', onDown, {once:true});
  overlay.addEventListener('mouseup', onUp, {once:true});
}

chrome.runtime.onMessage.addListener((msg, sender, sendResponse)=>{
  if (msg.type === 'start-selection') {
    if (!overlay) createOverlay();
  }
});

extension/popup.js

async function loadCfg() {
  const s = await chrome.storage.sync.get(['serverUrl','token']);
  document.getElementById('serverUrl').value = s.serverUrl || '';
  document.getElementById('token').value = s.token || '';
}

async function saveCfg() {
  const serverUrl = document.getElementById('serverUrl').value.trim();
  const token = document.getElementById('token').value.trim();
  await chrome.storage.sync.set({ serverUrl, token });
}

// Load projects for quick picker
async function refreshProjects() {
  const {serverUrl, token} = await chrome.storage.sync.get(['serverUrl','token']);
  const sel = document.getElementById('project');
  sel.innerHTML = '<option value="">(none)</option>';
  if (!serverUrl || !token) return;
  try {
    const r = await fetch(`${serverUrl}/api/extension/projects`, {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    if (!r.ok) return;
    const json = await r.json();
    for (const p of (json.projects||[])) {
      const o = document.createElement('option');
      o.value = p.id; o.textContent = p.name;
      sel.appendChild(o);
    }
  } catch(e){}
}

document.getElementById('selectRegion').onclick = async () => {
  await saveCfg();
  const [tab] = await chrome.tabs.query({active:true, currentWindow:true});
  await chrome.tabs.sendMessage(tab.id, {type:'start-selection'});
  document.getElementById('status').textContent = 'Draw a rectangle on the page…';
};

chrome.runtime.onMessage.addListener(async (msg) => {
  if (msg.type === 'selection-complete') {
    const rect = msg.rect, dpr = msg.dpr;
    const [tab] = await chrome.tabs.query({active:true, currentWindow:true});
    const img = await chrome.tabs.captureVisibleTab(tab.windowId, {format:'png'});
    // Crop client-side
    const image = new Image(); image.src = img;
    await new Promise(r=> image.onload=r);
    const canvas = document.createElement('canvas');
    canvas.width = Math.round(rect.w * dpr);
    canvas.height = Math.round(rect.h * dpr);
    const ctx = canvas.getContext('2d');
    ctx.drawImage(
      image,
      Math.round(rect.x * dpr),
      Math.round(rect.y * dpr),
      Math.round(rect.w * dpr),
      Math.round(rect.h * dpr),
      0,0,canvas.width,canvas.height
    );
    window._captureDataUrl = canvas.toDataURL('image/png');
    document.getElementById('upload').disabled = false;
    document.getElementById('status').textContent = 'Region captured. Ready to upload.';
  }
});

document.getElementById('upload').onclick = async () => {
  document.getElementById('upload').disabled = true;
  const {serverUrl, token} = await chrome.storage.sync.get(['serverUrl','token']);
  if (!serverUrl || !token) { document.getElementById('status').textContent = 'Configure server/token first.'; return; }

  const notes = document.getElementById('notes').value;
  const tags = (document.getElementById('tags').value || '').split(',').map(s=>s.trim()).filter(Boolean);
  const projectId = document.getElementById('project').value || null;

  const payload = {
    projectId,
    url: (await chrome.tabs.query({active:true,currentWindow:true}))[0].url,
    title: (await chrome.tabs.query({active:true,currentWindow:true}))[0].title,
    platform: null,
    notes, tags,
    imageDataUrl: window._captureDataUrl,
    selectionRect: null,
    ocrText: null,
    source: { author: null, postedAt: null, metrics: {} },
    queueAnalysis: false
  };

  try {
    const r = await fetch(`${serverUrl}/api/extension/upload`, {
      method:'POST',
      headers: {'Content-Type':'application/json','Authorization': `Bearer ${token}`},
      body: JSON.stringify({ ...payload })
    });
    if (!r.ok) throw new Error('upload failed');
    document.getElementById('status').textContent = 'Uploaded ✓';
    document.getElementById('upload').disabled = true;
  } catch(e){
    document.getElementById('status').textContent = 'Offline; queued.';
    await chrome.storage.local.set({uploadQueue: [ {payload, attempts:0} ]});
  }
};

(async function init(){
  await loadCfg();
  await refreshProjects();
})();

HUMAN STOP B (Chrome):
	•	Open Chrome → chrome://extensions → enable Developer mode → Load unpacked → select the extension/ folder.
	•	Open Options → set Server URL (e.g., your Replit external URL) and paste a token from Settings → Extensions (in your app).
	•	Click the extension icon on any page → Select Region → Upload.
	•	Verify it appears in Captures Inbox in the correct Project with tags.

⸻

Task 7 — Tag logic recap (what’s implemented)
	•	DB: captures.tags is text[], with a GIN index for fast filtering.
	•	Extension: collects comma-separated tags → sends as array → server stores it directly.
	•	Server: /api/extension/tags aggregates tag frequencies for the user (optionally filter by project later).
	•	UI: you can surface tags on Captures Inbox, filters, and in Brief Builder selection modals.

(Future niceties: a “tags” table for canonicalization + synonyms; auto-suggestions using OCR/text; tag merging.)

⸻

Task 8 — Truth Analysis stub (optional now; ready for Phase 5/6)

Create server/services/analysis.ts:

import { supabaseAdmin } from '../lib/supabaseAdmin';

export async function runTruthAnalysis(captureId: string) {
  // TODO: call your AI pipeline, then update captures row
  await supabaseAdmin.from('captures').update({
    analysis_status: 'complete',
    analysis_run_id: `run_${Date.now()}`
  }).eq('id', captureId);
}

// worker (simple cron-like loop you can trigger on demand)
export async function processQueuedJobs() {
  const { data: jobs } = await supabaseAdmin
    .from('analysis_jobs').select('id, capture_id, status').eq('status','queued').limit(5);
  for (const j of jobs || []) {
    await supabaseAdmin.from('analysis_jobs').update({status:'running'}).eq('id', j.id);
    try {
      await runTruthAnalysis(j.capture_id);
      await supabaseAdmin.from('analysis_jobs').update({status:'complete'}).eq('id', j.id);
    } catch(e) {
      await supabaseAdmin.from('analysis_jobs').update({status:'failed'}).eq('id', j.id);
    }
  }
}

You can wire a private route to trigger it during dev:

app.post('/api/admin/process-analysis', async (_req,res) => {
  await processQueuedJobs();
  res.json({ ok: true });
});


⸻

Task 9 — Verify

Run:

npm run typecheck
npm run build
npm run start

	•	In app: go to Settings → Extensions → create a token (copy once).
	•	In Chrome extension Options: paste Server URL + Token.
	•	Use the extension on any page → Upload → Check captures row in Supabase and Storage object exists in captures/{user_id}/{capture_id}.png.
	•	Confirm tags saved and visible on your Captures UI (if you already render tags; if not, add them).

⸻

HUMAN STOP C — Supabase Storage public URL (optional)

If you want to render public images in the client without a signed URL:
	•	In Supabase, Storage → captures: keep bucket private (recommended), and the server can generate signed URLs when needed (safer).
	•	Or, if you set bucket public, the getPublicUrl we used will resolve to a public link. Private + signed URLs is better.

⸻

Notes & Next Steps
	•	This keeps the architecture unified (one frontend, one backend, one DB). The extension is just a client; it never speaks to Supabase directly or spins its own auth.
	•	We did include tags thoroughly: DB, index, extension UI input, server persistence, and a tag frequency endpoint.
	•	As you proceed with Phase 5/6 (Truth Analysis, Brief Builder 2.0), the captures created here will slot directly into those flows.

If you want, I can follow up with:
	•	A quick Captures Inbox filter by tags/project,
	•	A tiny “Tag cloud” component using /api/extension/tags,
	•	And a signed-URL helper for rendering private images safely.