

# Lovable AI Prompt — Frontend Redesign & Implementation (Drop-In Compatible)

## 0) Goal

Design and implement an elegant, dark-theme front end for a strategist workflow that **drops into our existing monorepo** with **zero backend changes**. Keep it intuitive, fast, and clean. Deliver production-ready React + TypeScript code and components that map 1:1 to our API contracts and routing so we can replace our current UI with minimal lift.

---

## 1) Tech & Constraints

* **Framework:** React 18 + TypeScript + Vite
* **Routing:** react-router-dom v6
* **Styling:** TailwindCSS (dark theme first). Use CSS variables/tokens for colors.
* **Components:** Prefer headless patterns; feel free to include a lightweight UI kit if fully tree-shakable.
* **State:** TanStack Query v5 for server data; React state for local UI.
* **Auth:** Supabase Auth (we already have it wired up; you only integrate via hook below).
* **Build:** Must pass `npx tsc --noEmit` with no errors.
* **A11y & Perf:** Keyboard nav, focus states, ARIA where appropriate, code-split pages, lazy image loading, skeletons.
* **Theme:** Dark by default, light optional. Keep visual language minimal, modern, and calm.

---

## 2) Folder & File Structure (exact)

```
client/
  src/
    app/
      App.tsx
      routes.tsx
      providers/
        QueryProvider.tsx
        ThemeProvider.tsx
        ToasterProvider.tsx
    components/
      layout/
        Sidebar.tsx
        Topbar.tsx
        Page.tsx
      common/
        Button.tsx
        Input.tsx
        Select.tsx
        Spinner.tsx
        EmptyState.tsx
        ErrorState.tsx
        Skeleton.tsx
      dashboard/
        StatsOverview.tsx
        TrendChart.tsx
      signals/
        SignalCard.tsx
        SignalList.tsx
        SignalFilters.tsx
      briefs/
        BriefEditor.tsx
        BriefSection.tsx
        BriefSignalPicker.tsx
    pages/
      dashboard.tsx
      signals.tsx
      briefs.tsx
      brief-detail.tsx
      settings.tsx
      login.tsx
    lib/
      api.ts           // apiFetch wrapper (see signature below)
      auth.ts          // useAuth hook (see signature below)
      query.ts         // query keys/helpers
      types.ts         // shared types (see below)
      utils.ts
    styles/
      tailwind.css
    main.tsx
  index.html
```

> If you need any other file, propose it, but do not change existing backend paths or environment variable names.

---

## 3) Data Contracts & Types (use exactly these)

Create `client/src/lib/types.ts` with:

```ts
// Auth
export type AuthUser = {
  id: string;
  email: string;
  role?: string;
  metadata?: any;
};

// Signals (captured items from social/web)
export type Signal = {
  id: string;
  title: string;
  source: string;           // e.g., twitter, tiktok, reddit, web, youtube, instagram
  url: string;
  image?: string | null;
  captured_at: string;      // ISO string
  tags: string[];
  excerpt?: string | null;
};

// Briefs
export type BriefSection = {
  heading: string;
  content: string;          // markdown supported
  signals: string[];        // array of Signal IDs
};

export type Brief = {
  id: string;
  title: string;
  sections: BriefSection[];
  created_at: string;
  updated_at: string;
};

// Dashboard stats (keep minimal; extend safe)
export type DashboardStats = {
  totalSignals: number;
  activeBriefs: number;
  avgViralScore?: number;
  engagementRate?: number;
  responseTime?: string;
};

// Intelligence summary (used for trend summaries)
export type IntelligenceSummary = {
  totalSignals: number;
  tier1Signals: number;
  tier2Signals: number;
  trends: number;
};

// Generic API envelope (if needed)
export type Paginated<T> = { items: T[]; total: number; page: number; pageSize: number; };
```

> Do **not** invent new fields. If you need a field not listed, render the UI so it degrades gracefully when absent.

---

## 4) API Wrapper & Auth (use exactly these signatures)

Create `client/src/lib/api.ts`:

```ts
export async function apiFetch<T>(
  path: string,
  options: RequestInit & { auth?: boolean } = { auth: true }
): Promise<T> {
  const base = import.meta.env.VITE_API_BASE_URL;
  const headers: Record<string, string> = { 'Content-Type': 'application/json', ...(options.headers as any) };

  if (options.auth) {
    const token = localStorage.getItem('jwt'); // backend already issues & stores this
    if (token) headers.Authorization = `Bearer ${token}`;
  }

  const res = await fetch(`${base}${path}`, { ...options, headers });
  if (!res.ok) {
    const text = await res.text().catch(() => '');
    throw new Error(text || `Request failed: ${res.status}`);
  }
  return res.json() as Promise<T>;
}
```

Create `client/src/lib/auth.ts`:

```ts
import { useEffect, useState, useCallback } from 'react';
import type { AuthUser } from './types';

export function useAuth() {
  const [user, setUser] = useState<AuthUser | null>(null);
  const [isLoading, setLoading] = useState(true);

  useEffect(() => {
    // backend places jwt in localStorage and exposes /auth/me
    const init = async () => {
      try {
        const me = await fetch('/auth/me', { headers: { Authorization: `Bearer ${localStorage.getItem('jwt') || ''}` }});
        if (me.ok) {
          const data = await me.json();
          setUser(data.user as AuthUser);
        } else {
          setUser(null);
        }
      } catch {
        setUser(null);
      } finally {
        setLoading(false);
      }
    };
    init();
  }, []);

  const login = useCallback(async (email: string, password: string) => {
    const res = await fetch('/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });
    if (!res.ok) throw new Error('Login failed');
    const data = await res.json();
    localStorage.setItem('jwt', data.token);
    window.location.reload();
  }, []);

  const logout = useCallback(async () => {
    localStorage.removeItem('jwt');
    window.location.assign('/login');
  }, []);

  return { user, isLoading, isAuthenticated: !!user, login, logout };
}
```

> Do **not** add `setUser` to the public API. Pages must rely on `login/logout` and `/auth/me`.

---

## 5) Routes & Pages (must match these paths)

* `/login` — public
* `/dashboard` — protected
* `/signals` — protected
* `/briefs` — protected (list)
* `/briefs/:id` — protected (editor)
* `/settings` — protected

### Page behaviors

* **dashboard.tsx**

  * Show `StatsOverview` with `DashboardStats`
  * Latest 6 Signals in a grid of `SignalCard`
* **signals.tsx**

  * `SignalFilters` (source, date range, tags search)
  * `SignalList` virtualized list; each item links to source (`url`) and supports “Add to Brief” action
* **briefs.tsx**

  * List all briefs; `New Brief` button
* **brief-detail.tsx**

  * `BriefEditor` with sections
  * Right rail: `BriefSignalPicker` (search signals and drag/drop to sections)
  * Export buttons: Markdown & PDF (hook up to existing endpoints; if not present, call placeholders)
* **settings.tsx**

  * Profile view (read-only for now)
  * Theme toggle (dark/light)

All protected pages:

* Redirect unauthenticated users to `/login`.

---

## 6) Components (props and contracts)

Design with clean, neutral dark theme. All components must be **fully typed**.

* `StatsOverview.tsx`

  ```ts
  type Props = { stats?: DashboardStats };
  export default function StatsOverview({ stats }: Props): JSX.Element;
  ```

  Cards: Total Signals, Active Briefs, Avg Viral Score (optional), Engagement Rate (optional)

* `TrendChart.tsx`

  ```ts
  type Props = { title: string; data: Array<{ date: string; value: number }> };
  export default function TrendChart(props: Props): JSX.Element;
  ```

* `SignalCard.tsx`

  ```ts
  type Props = { signal: Signal; onAddToBrief?: (signalId: string) => void };
  export default function SignalCard(props: Props): JSX.Element;
  ```

* `SignalList.tsx`

  ```ts
  type Props = {
    items: Signal[];
    onAddToBrief?: (signalId: string) => void;
    isLoading?: boolean;
    error?: Error | null;
  };
  export default function SignalList(props: Props): JSX.Element;
  ```

* `SignalFilters.tsx`

  ```ts
  type Props = {
    sources: string[];
    value: { q: string; source?: string; tags?: string[]; from?: string; to?: string };
    onChange: (v: Props['value']) => void;
  };
  export default function SignalFilters(props: Props): JSX.Element;
  ```

* `BriefEditor.tsx`

  ```ts
  type Props = {
    brief: Brief;
    onChange: (next: Brief) => void;
    onSave: () => Promise<void>;
    onExportPdf?: () => Promise<void>;
    onExportMarkdown?: () => Promise<void>;
  };
  export default function BriefEditor(props: Props): JSX.Element;
  ```

* `BriefSection.tsx`

  ```ts
  type Props = {
    section: BriefSection;
    onChange: (next: BriefSection) => void;
    onRemove: () => void;
  };
  export default function BriefSection(props: Props): JSX.Element;
  ```

* `BriefSignalPicker.tsx`

  ```ts
  type Props = {
    query: string;
    onQueryChange: (q: string) => void;
    results: Signal[];
    onAttach: (signalId: string, sectionIndex: number) => void;
  };
  export default function BriefSignalPicker(props: Props): JSX.Element;
  ```

---

## 7) Data Fetching (TanStack Query keys)

Create `client/src/lib/query.ts`:

```ts
export const qk = {
  signals: (params?: any) => ['signals', params] as const,
  signal: (id: string) => ['signal', id] as const,
  briefs: () => ['briefs'] as const,
  brief: (id: string) => ['brief', id] as const,
  dashboard: () => ['dashboard'] as const
};
```

### Required endpoints (consume via `apiFetch`):

* `GET /api/dashboard` → `DashboardStats`
* `GET /api/signals` → `Paginated<Signal>`
* `GET /api/briefs` → `Brief[]`
* `GET /api/briefs/:id` → `Brief`
* `PATCH /api/briefs/:id` → `Brief`
* `POST /api/briefs` → `Brief`
* `POST /api/briefs/:id/export/pdf` → `{ url: string }` (or file stream)
* `POST /api/briefs/:id/export/md` → `{ content: string }`

> If an endpoint is missing at dev time, create a client-side placeholder function with a clear TODO and keep UI working with mock data, **but do not change the data shapes**.

---

## 8) UX Details

* **Dark theme tokens** (example, adapt as CSS variables):

  * bg: `#0B0D10`
  * panel: `#12161B`
  * border: `#1E232B`
  * text: `#E5EAF0`
  * subtext: `#9AA4B2`
  * brand/accent: `#7C5CFF`
* **States**: Loading skeletons, zero states (`EmptyState`), and inline error banners (`ErrorState`).
* **List density**: Compact, high-scanability.
* **Source links**: Always visible on signals (open in new tab).
* **Keyboard**: Tab order logical; Enter/Escape for dialogs; space/enter on primary actions.

---

## 9) Acceptance Criteria

1. `npx tsc --noEmit` passes (no type errors).
2. `npm run dev` launches with no runtime errors in the console.
3. All protected routes redirect to `/login` when unauthenticated.
4. All pages render with mock or live data without breaking the contracts in **§3**.
5. Exports call the specified endpoints (or placeholders) and display success/error toasts.
6. The UI is responsive (≥320px width) and accessible (visible focus, labels for inputs).
7. No hardcoded API URLs—must use `VITE_API_BASE_URL` with `apiFetch`.

---

## 10) Hand-Off Deliverables

* All components and pages as in **§2** with the props in **§6**.
* A minimal **README** that explains:

  * how to run locally,
  * where to configure `VITE_API_BASE_URL`,
  * where types live,
  * how `apiFetch` and `useAuth` are expected to work.
* Optional figma or screenshots for layout reference (nice to have).

---

## 11) Visual Style Cues

* Keep the interface **calm, sparse, and readable** (no visual clutter).
* Use soft shadows, large hit targets, clear hierarchy.
* Maintain the dark color scheme with a single accent color.

---

If anything is unclear, propose a clarification **without** changing data contracts or route paths. The top priority is **drop-in compatibility** and **TypeScript correctness**.
