Awesome — let’s keep the momentum going. Here’s a single Replit Task Runbook you can paste into Replit Tasks to continue right from the “Google export scaffolding complete” state. It wires up the backend API that the new UI will consume, adds slide storage for the Brief Canvas, implements tags, and gives you human stops where you need to confirm things.

⸻

Task Block #2 — UI-v2 Backend Contracts, Slides Storage, Tags, and Export Job

Goal: Expose clean REST endpoints (API-first) for Projects, Captures, Moments, Briefs (with slides JSON), Feeds, Auth, and Export. No direct Supabase from the client. Make sure everything matches the UI-v2 DTOs we defined (Brief, BriefDetail, Slide, Block, etc.). Keep Google export scaffolding intact.

Assumptions
	•	Supabase project + RLS already set.
	•	Env vars already set (VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY, SUPABASE_JWT_SECRET, GOOGLE_CLIENT_ID/SECRET, etc.).
	•	Server runs on port 5000, client on 5173 (or your Replit external URL).
	•	We’ll keep the existing app working while we add these new endpoints.

⸻

Step 0 — Preflight
	1.	Show current env summary (no secrets)

echo "SUPABASE URL: ${VITE_SUPABASE_URL}"
echo "Has ANON KEY: $([ -n "$VITE_SUPABASE_ANON_KEY" ] && echo yes || echo no)"
echo "Has SERVICE ROLE KEY: $([ -n "$SUPABASE_SERVICE_ROLE_KEY" ] && echo yes || echo no)"
echo "Has SUPABASE_JWT_SECRET: $([ -n "$SUPABASE_JWT_SECRET" ] && echo yes || echo no)"

	2.	Install server deps (if needed for validation/helpers)

npm i zod dayjs

If anything missing (esp. SUPABASE_JWT_SECRET), STOP and ask for the value.

⸻

Step 1 — DB Migration: add slides jsonb and tags consistency

Create a SQL migration (we’ll run it in Supabase SQL editor or Replit if CLI is available). Save to supabase/migrations/2025-briefs-slides.sql:

-- Add slides jsonb to dsd_briefs if not present
alter table if exists public.dsd_briefs
  add column if not exists slides jsonb default '[]'::jsonb;

-- Ensure tags arrays exist with correct type on captures/moments/briefs
alter table if exists public.captures
  alter column tags type text[] using (
    case when tags is null then array[]::text[]
         when jsonb_typeof(to_jsonb(tags)) = 'array' then
           (select array_agg(elem::text) from jsonb_array_elements_text(to_jsonb(tags)) elem)
         else array[]::text[] end
  ),
  alter column tags set default array[]::text[];

alter table if exists public.cultural_moments
  alter column tags type text[] using (
    case when tags is null then array[]::text[]
         when jsonb_typeof(to_jsonb(tags)) = 'array' then
           (select array_agg(elem::text) from jsonb_array_elements_text(to_jsonb(tags)) elem)
         else array[]::text[] end
  ),
  alter column tags set default array[]::text[];

alter table if exists public.dsd_briefs
  add column if not exists tags text[] default array[]::text[];

-- Simple GIN indexes for tag filters
create index if not exists idx_captures_tags on public.captures using gin (tags);
create index if not exists idx_moments_tags on public.cultural_moments using gin (tags);
create index if not exists idx_briefs_tags on public.dsd_briefs using gin (tags);

-- Touch updated_at on update
drop trigger if exists trg_dsd_briefs_touch_updated_at on public.dsd_briefs;
create trigger trg_dsd_briefs_touch_updated_at
before update on public.dsd_briefs
for each row execute function public.touch_updated_at();

HUMAN STEP: Run this SQL in Supabase SQL Editor. When done, return here and continue.

⸻

Step 2 — Shared DTOs & mapping layer (server)
	1.	Create a server types file server/types/dto.ts with the DTOs we expect the UI-v2 to use:

export type ID = string;
export type Tag = string;

export interface Project { id: ID; name: string; description?: string | null; createdAt: string; updatedAt: string; }
export interface Capture { id: ID; projectId: ID; userId: ID; title: string; content: string; platform?: string | null; url?: string | null; tags: Tag[]; status: 'new'|'keep'|'trash'; imageUrl?: string | null; videoUrl?: string | null; createdAt: string; updatedAt: string; }
export interface Moment { id: ID; title: string; description: string; intensity: number; tags: Tag[]; platforms: string[]; createdAt: string; updatedAt: string; }
export interface Brief { id: ID; projectId: ID; title: string; status: 'draft'|'in_review'|'final'; tags: Tag[]; slideCount: number; updatedAt: string; createdAt: string; }

export type BlockType = 'text'|'image'|'note';
export interface BaseBlock { id: ID; type: BlockType; x: number; y: number; w: number; h: number; rotation?: number; }
export interface TextBlock extends BaseBlock { type: 'text'; text: string; align?: 'left'|'center'|'right'; fontSize?: number; weight?: number; }
export interface ImageBlock extends BaseBlock { type: 'image'; src: string; alt?: string | null; sourceCaptureId?: ID | null; }
export interface NoteBlock extends BaseBlock { type: 'note'; text: string; }
export type Block = TextBlock | ImageBlock | NoteBlock;

export interface Slide { id: ID; title?: string | null; blocks: Block[]; captureRefs?: ID[]; }
export interface BriefDetail extends Brief { slides: Slide[]; }

export interface Feed { id: ID; userId: ID; projectId?: ID | null; feedUrl: string; title?: string | null; isActive: boolean; createdAt: string; updatedAt: string; }

	2.	Create mappers server/lib/mappers.ts that convert DB rows → DTOs and back. (Read DB with your current storage layer and map date fields to ISO strings, ensure slides is valid JSON array.)

⸻

Step 3 — Auth endpoints

Add routes server/routes/auth.ts:
	•	GET /api/auth/me → read Authorization: Bearer <supabase_jwt> or cookie, verify using SUPABASE_JWT_SECRET, return basic user profile {id,email,name,avatarUrl} or null.
	•	POST /api/auth/google/start → if needed, just return { ok: true } (UI button can still work as a placeholder because Supabase auth is happening on the client); or proxy to your existing Google flow if already implemented.

Wire into server/index.ts (or your main router). Keep CORS & JSON middlewares.

⸻

Step 4 — Projects API

Add routes server/routes/projects.ts:
	•	GET /api/projects → list projects owned by user.
	•	POST /api/projects → create { name, description? }.
	•	PATCH /api/projects/:id → update.
	•	DELETE /api/projects/:id → delete (optional now).

Use existing storage methods if present; otherwise add simple queries via your storage layer. Return Project DTOs.

⸻

Step 5 — Captures API (triage + filters + tags)

Add routes server/routes/captures.ts:
	•	GET /api/captures?projectId=&status=&q=&tags=tag1,tag2&page=&pageSize=
	•	server-side pagination; filter by status and tags (ANY match), simple q ilike search on title/content.
	•	PATCH /api/captures/:id
	•	allow updating { status, tags }.

Map DB rows to Capture DTOs; status default 'new' if null. Ensure tags an array.

⸻

Step 6 — Moments API

Add routes server/routes/moments.ts:
	•	GET /api/moments?projectId=&tags=&q=
	•	PATCH /api/moments/:id (optional now)

Map to Moment DTOs; include intensity (if missing, compute a placeholder like 0–100 from recent activity count until analytics is wired).

⸻

Step 7 — Briefs API (+slides)

Add routes server/routes/briefs.ts:
	•	GET /api/briefs?projectId=&q=&tags= → return array of Brief (compute slideCount from slides.length).
	•	POST /api/briefs → create { projectId, title } and set { slides: [] }.
	•	GET /api/briefs/:id → return full BriefDetail (slides JSON).
	•	PATCH /api/briefs/:id → update meta { title?, status?, tags? }.
	•	POST /api/briefs/:id/save → accept full BriefDetail and persist (replace slides atomically, update updated_at).

Make sure slides is validated as an array; if invalid, return 400.

⸻

Step 8 — Export API (job-style)

You already scaffolded Google export. We’ll keep the job shape for the UI:
	•	POST /api/briefs/:id/export → create a job { jobId }, kick off export (can be sync under the hood), store { status: 'completed', url } in an in-memory map for now.
	•	GET /api/jobs/:jobId → { status: 'pending'|'completed'|'failed', url?: string, error?: string }.

Keep your existing .../export/slides working; this route simply orchestrates and returns jobId.

⸻

Step 9 — Feeds API

Add routes server/routes/feeds.ts backed by user_feeds:
	•	GET /api/feeds?projectId= → list
	•	POST /api/feeds → create { feedUrl, title?, projectId? }
	•	PATCH /api/feeds/:id/toggle → toggle active
	•	DELETE /api/feeds/:id

Return Feed DTOs.

⸻

Step 10 — Replace any remaining direct Supabase calls on the client

Scan for files still calling Supabase directly:
	•	client/src/hooks/useBriefs.ts
	•	client/src/hooks/useCaptures.ts
	•	client/src/hooks/useMoments.ts
	•	client/src/services/feeds.ts

Refactor each to call our new endpoints via a tiny client/src/services/api/*.ts wrapper (or reuse the ones you added earlier). Make sure React Query keys are stable (['briefs', projectId], etc.).

Command to verify:

grep -R "from '@supabase/supabase-js'" -n client | wc -l

If >0 in app code (not just the Supabase client init), remove/refactor.

⸻

Step 11 — Health checks & quick tests
	1.	Typecheck & build

npm run typecheck || npx tsc --noEmit
npm run build || echo "client may skip; focus is server for now"

	2.	Start server and probe

npm run server & sleep 2

# assume you have a valid JWT to test or a dev bypass; otherwise just check 401/403 are returned
curl -i http://localhost:5000/api/auth/me
curl -i "http://localhost:5000/api/projects"
curl -i "http://localhost:5000/api/briefs?projectId=<some-id>"

HUMAN STEP: If /api/auth/me always returns null while you’re logged in, confirm the client is sending Authorization: Bearer <access_token> to the server (we can add a dev toggle if needed).

⸻

Step 12 — Commit & report
	•	Commit all changes with message:

feat(api): add UI-v2 contracts (auth, projects, captures, moments, briefs with slides, feeds, export jobs); add slides jsonb; normalize tags

	•	Output a brief status report:
	•	Which endpoints are live
	•	DB migration success
	•	Any remaining client call sites to refactor (if found)
	•	Anything blocked (auth header wiring, etc.)

⸻

Success criteria
	•	DB has dsd_briefs.slides jsonb and tag arrays indexed.
	•	Endpoints live: /api/auth/me, /api/projects, /api/captures, /api/moments, /api/briefs, /api/briefs/:id, /api/briefs/:id/save, /api/briefs/:id/export, /api/jobs/:jobId, /api/feeds.
	•	No remaining direct Supabase calls in client data hooks/services.
	•	Export job returns { jobId } and polling shows completed with a Slides URL (or dev stub URL).
	•	Typecheck passes. Server runs without errors.

If anything fails, stop and summarize the failure (file + line + stack) and propose a fix before proceeding.

⸻

If you want, I can follow up with the Bolt handoff prompt to ensure the UI-v2 services hit these exact endpoints and DTO shapes.