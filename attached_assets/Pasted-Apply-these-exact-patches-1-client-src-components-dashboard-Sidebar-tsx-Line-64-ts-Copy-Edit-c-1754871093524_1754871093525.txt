Apply these exact patches
1) client/src/components/dashboard/Sidebar.tsx
Line ~64:

ts
Copy
Edit
- const data = await response.text();
+ const data = (response as { url: string }).url;
2) client/src/components/dashboard/TrendModal.tsx
Your API returns string[]. Fix the success handler:

ts
Copy
Edit
- setAdditionalHooks(data.hooks);
- toast({ description: `Generated ${data.hooks.length} additional hooks` });
+ setAdditionalHooks(data);
+ toast({ description: `Generated ${data.length} additional hooks` });
If you prefer { hooks: string[] }, then change your mutation type + server instead and keep the old UI.

3) client/src/lib/lovable-api.ts
Replace the two .getStats() calls and stop reading .data off responses.

ts
Copy
Edit
- const response = await api.getStats();
+ const response = await api.get<DashboardStats>('/api/stats');

...

- return response.data;
+ return response;
Do this in both places (lines ~76, ~97, ~133, ~143).

Also, your mapping references fields not in DashboardStats. See #4.

4) Unify DashboardStats (fixes “two different types” and missing fields)
Create/ensure a single source of truth:

client/src/types/dashboard.ts

ts
Copy
Edit
export type DashboardStats = {
  // core
  totalTrends?: number;
  viralPotential?: number;
  activeSources?: number;
  avgScore?: number;

  // extra used across pages
  truthAnalyzed?: number;
  hypothesesTracked?: number;

  // fields used in lovable-api mapping
  totalCaptures?: number;
  avgViralScore?: number;
  engagementRate?: number;
  responseTime?: string;
};
Then in every file that imports/declares DashboardStats (notably StatsOverview.tsx, pages/dashboard.tsx, lib/lovable-api.ts), replace local declarations with:

ts
Copy
Edit
import type { DashboardStats } from '@/types/dashboard';
Update client/src/components/dashboard/StatsOverview.tsx to use optional chaining/fallbacks:

ts
Copy
Edit
value: stats?.truthAnalyzed ?? 0,
...
value: stats?.hypothesesTracked ?? 0,
In client/src/lib/lovable-api.ts where you build a friendly object from /api/stats, these props now exist:

ts
Copy
Edit
activeSignals: response.totalCaptures ?? 0,
avgViralScore: response.avgViralScore ?? 0,
engagementRate: response.engagementRate ?? 0,
responseTime:   response.responseTime   ?? 'N/A',
5) client/src/pages/analysis.tsx
You’re calling setAnalysisResult(data) where data is unknown, and you reference analyzeTruth which isn’t defined. Define the mutation with types and use its name everywhere you reference it:

ts
Copy
Edit
import { useMutation } from '@tanstack/react-query';

type AnalyzePayload = { content: string; projectId?: string };

const analyzeTruth = useMutation({
  mutationFn: (payload: AnalyzePayload) =>
    api.post<TruthAnalysis>('/api/truth-analysis/analyze', payload),
  onSuccess: (data) => setAnalysisResult(data),
});
Then the JSX bits using analyzeTruth.isPending will compile.

6) client/src/pages/brief-builder.tsx
selectedProject is a string id, not an object:

tsx
Copy
Edit
- projectId={selectedProject?.id || ''}
+ projectId={selectedProject || ''}
7) client/src/pages/capture-tagging-enhanced.tsx
Make platforms a string[] (so .map((platform: string) => ...) is valid):

Where platforms is fetched:

ts
Copy
Edit
const { data: platforms = [] } = useQuery<string[]>({
  queryKey: ['platforms'],
  queryFn: () => api.get<string[]>('/api/platforms'),
});
(If you’re building it locally, ensure it’s typed string[] before .map.)

8) client/src/pages/intelligence.tsx
You’re using a useQuery result as if it had mutate. Either call refetch() or convert to a mutation. If this is a fetch, change:

ts
Copy
Edit
- fetchIntelligence.mutate({ ... })
+ fetchIntelligence.refetch()
And type the query result so property reads compile:

ts
Copy
Edit
type IntelligenceSummary = {
  totalSignals: number;
  tier1Signals: number;
  tier2Signals: number;
  trends: number;
};

const fetchIntelligence = useQuery<IntelligenceSummary, Error>({
  queryKey: ['intelligence'],
  queryFn: () => api.get<IntelligenceSummary>('/api/intelligence/summary'),
});

<div>{fetchIntelligence.data?.totalSignals ?? 0}</div>
9) client/src/pages/login.tsx and client/src/pages/register.tsx
Remove setUser if your context doesn’t expose it:

ts
Copy
Edit
- const { setUser } = useAuth();
+ const { user, isLoading, isAuthenticated, logout } = useAuth();
…and delete any remaining uses of setUser.

10) Project/capture arrays used in multiple pages
Everywhere TS says “is of type unknown” on projects, captures, etc, type the queries and set array defaults.

Example pattern (apply in: lovable-capture.tsx, manage.tsx, signal-capture.tsx, truth-analysis.tsx):

ts
Copy
Edit
const { data: projects = [] } = useQuery<Project[]>({
  queryKey: ['projects'],
  queryFn: () => api.get<Project[]>('/api/projects'),
});
11) client/src/pages/my-captures.tsx
Project lacks title. Either add it to the Project type or fallback:

tsx
Copy
Edit
- {project.title}
+ {project.title ?? project.name ?? 'Untitled'}
12) client/src/pages/new-dashboard.tsx
Provide required prop:

tsx
Copy
Edit
<TrendChart title="Capture Trends" data={chartData} />
13) server/middleware/auth.ts
The base Request’s user.email is string (not optional). Make your AuthedUser match:

ts
Copy
Edit
export interface AuthedUser {
  id: string;
  email: string;   // must be string to satisfy the extended Request type
  role?: string;
  metadata?: any;
}
export interface AuthedRequest extends Request {
  user?: AuthedUser;
}
(If you sometimes don’t have an email, ensure you set '' or a known placeholder before assigning to req.user.)

14) server/routes/google-exports.ts
Map service returns to the { id, title } your type requires; also guard imageData, and don’t pass richer capture objects to services expecting simpler DTOs.

Right after calling the services:

ts
Copy
Edit
const slidesRaw = await slidesService.createPresentationFromBrief(briefData);
const docsRaw   = await docsService.createDetailedBriefDocument(briefData);
const sheetsRaw = await sheetsService.createAnalysisSpreadsheet(briefData);

const slidesResult = { id: String(slidesRaw.presentationId), title: slidesRaw.title };
const docsResult   = { id: String(docsRaw.documentId),       title: docsRaw.title };
const sheetsResult = { id: String(sheetsRaw.spreadsheetId),  title: sheetsRaw.title };

res.json({ slides: slidesResult, docs: docsResult, sheets: sheetsResult });
Guard image captures:

ts
Copy
Edit
const capturesWithImages =
  (captures ?? []).filter((c: any) => c.type === 'image' && !!(c as any).imageData) as Array<{
    title: string; content: string; type: string; imageData: string;
  }>;
If your service params expect simple captures { title: string; content: string; ... }, map them before passing. Also, remove unsupported lastAnalyzed from updates or add it to your storage type.

Where you reference project.definePoints/shiftPoints/deliverPoints, guard via cast:

ts
Copy
Edit
define: (project as any).definePoints ?? [],
shift:  (project as any).shiftPoints ?? [],
deliver:(project as any).deliverPoints ?? [],
15) server/routes/projects.ts
content can be null:

ts
Copy
Edit
- content: capture.content,
+ content: capture.content ?? '',
16) server/services/brightDataBrowser.ts
Type arrays and safely read href:

At each array declaration:

ts
Copy
Edit
const extractedVideos: Array<{ url: string; [k: string]: any }> = [];
const extractedTweets: Array<{ url: string; [k: string]: any }> = [];
When reading href:

ts
Copy
Edit
const linkElement = el.querySelector('a');
const url =
  (linkElement as HTMLAnchorElement | null)?.href ??
  linkElement?.getAttribute('href') ??
  '';
Apply the same pattern wherever TS complains about .href.

17) server/services/capture-analysis-service.ts
Map your TruthAnalysisResult to the storage shape, and stringify visualAnalysis if storage expects a string:

ts
Copy
Edit
updates.truthAnalysis = {
  fact: {
    claims: analysisResult.truthAnalysis.claims,
    sources: analysisResult.truthAnalysis.sources,
    verificationStatus: analysisResult.truthAnalysis.verificationStatus,
    confidence: analysisResult.truthAnalysis.confidence,
  },
  observation: { /* map fields */ },
  insight: { /* map fields */ },
  humanTruth: { /* map fields */ },
};

updates.visualAnalysis = JSON.stringify(analysisResult.visualAnalysis);

// if metadata exists:
updates.metadata = updates.metadata as unknown as Json | undefined;
18) server/services/chromeExtensionService.ts
Unknown error → message safely; add index signatures:

ts
Copy
Edit
} catch (error) {
  const msg = (error as Error)?.message ?? String(error);
  throw new Error(`Failed to process captured content: ${msg}`);
}

const platformMultipliers: Record<string, number> = {
  twitter: 1.2, tiktok: 1.3, instagram: 1.1, linkedin: 1.0, youtube: 1.15, reddit: 1.05, web: 1.0,
};
score *= platformMultipliers[content.platform || 'web'] || 1.0;

const platformWeights: Record<string, number> = {
  twitter: 60, tiktok: 70, instagram: 55, linkedin: 45, reddit: 50,
};
const platformWeight = platformWeights[content.platform || 'twitter'] || 50;
19) server/services/google-custom-search-service.ts
Index signature + access by key:

ts
Copy
Edit
const siteMap: Record<string, string> = {
  reddit: 'site:reddit.com',
  twitter: 'site:twitter.com',
  tiktok: 'site:tiktok.com',
  instagram: 'site:instagram.com',
  youtube: 'site:youtube.com',
  linkedin: 'site:linkedin.com',
};

if (options.platform && siteMap[options.platform]) {
  searchParams.q += ` ${siteMap[options.platform]}`;
}

// ensure campaignInsights is typed as an array
intelligence.campaignInsights = (intelligence.campaignInsights ?? []) as Array<{
  title: string; url: string; platform: string; insights: string[];
}>;
intelligence.campaignInsights.push({
  title: result.title,
  url: result.link,
  platform: options.platform ?? 'web',
  insights: this.extractCampaignInsights(result.snippet),
});
20) server/services/google-vision-service.ts
Allow object assignment:

ts
Copy
Edit
// safetyAnalysis was null | object; make it object-compatible in its type or:
(analysis as any).safetyAnalysis = {
  adult, violence, racy, medical, spoof,
};
21) server/services/liveBrightDataService.ts
Remove unsupported option

Type limit

Type locals

Safe href

ts
Copy
Edit
connect({
  // remove: ignoreHTTPSErrors
});

const posts = await page.evaluate((limit: number) => { /* ... */ });

let foundElements: Element[] = [];

const tweets = await page.evaluate((limit: number) => { /* ... */ });
const videos = await page.evaluate((limit: number) => { /* ... */ });

url: (video as unknown as HTMLAnchorElement)?.href || window.location.href,
(Repeat for other page.evaluate blocks flagged.)

22) vite.config.ts
ts
Copy
Edit
server: {
-  allowedHosts: "all",
+  allowedHosts: true,
},
