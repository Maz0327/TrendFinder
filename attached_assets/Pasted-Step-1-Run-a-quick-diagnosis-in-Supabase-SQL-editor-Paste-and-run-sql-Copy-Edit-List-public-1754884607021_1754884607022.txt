Step 1 — Run a quick diagnosis (in Supabase SQL editor)
Paste and run:

sql
Copy
Edit
-- List public tables
select table_name
from information_schema.tables
where table_schema = 'public'
order by table_name;

-- Describe columns we care about
select 'captures' as table, column_name, data_type, is_nullable
from information_schema.columns
where table_schema='public' and table_name='captures'
union all
select 'dsd_briefs', column_name, data_type, is_nullable
from information_schema.columns
where table_schema='public' and table_name='dsd_briefs'
union all
select 'cultural_moments', column_name, data_type, is_nullable
from information_schema.columns
where table_schema='public' and table_name='cultural_moments'
order by table, column_name;
If dsd_briefs isn’t listed (or columns are missing), proceed to Step 2.

Step 2 — Idempotent fix (safe to run even if parts already exist)
This will create missing tables/columns and add the actual_virality column, without dropping data.

Run all of this in the Supabase SQL editor.

sql
Copy
Edit
-- 1) Helper to keep updated_at in sync
create or replace function public.touch_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

-- 2) captures (create if not exists; patch columns if missing)
create table if not exists public.captures (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null,
  title text not null,
  content text not null,
  platform text,
  url text,
  tags text[],
  viral_score numeric,
  ai_analysis jsonb,
  dsd_tags text[],
  dsd_section text,
  predicted_virality numeric,
  actual_virality numeric,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Ensure columns exist with correct types
alter table public.captures
  add column if not exists actual_virality numeric;

alter table public.captures
  add column if not exists ai_analysis jsonb;

alter table public.captures
  add column if not exists predicted_virality numeric;

-- Optional: ensure arrays are arrays (migrate from jsonb if prior drift existed)
-- If tags is jsonb, convert it:
do $$
begin
  if exists (
    select 1 from information_schema.columns
    where table_schema='public' and table_name='captures'
      and column_name='tags' and data_type='jsonb'
  ) then
    alter table public.captures
      alter column tags drop default;
    alter table public.captures
      alter column tags type text[] using
        case
          when jsonb_typeof(tags)='array' then
            array(select jsonb_array_elements_text(tags))
          else null
        end;
  end if;
end$$;

-- If dsd_tags is jsonb, convert it too:
do $$
begin
  if exists (
    select 1 from information_schema.columns
    where table_schema='public' and table_name='captures'
      and column_name='dsd_tags' and data_type='jsonb'
  ) then
    alter table public.captures
      alter column dsd_tags drop default;
    alter table public.captures
      alter column dsd_tags type text[] using
        case
          when jsonb_typeof(dsd_tags)='array' then
            array(select jsonb_array_elements_text(dsd_tags))
          else null
        end;
  end if;
end$$;

-- Touch trigger for captures
do $$
begin
  if not exists (
    select 1 from pg_trigger
    where tgname = 'captures_touch_updated_at'
  ) then
    create trigger captures_touch_updated_at
      before update on public.captures
      for each row
      execute procedure public.touch_updated_at();
  end if;
end$$;

-- 3) dsd_briefs
create table if not exists public.dsd_briefs (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null,
  client_profile_id uuid,
  title text not null,
  status text,
  define_section jsonb,
  shift_section jsonb,
  deliver_section jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

do $$
begin
  if not exists (
    select 1 from pg_trigger
    where tgname = 'dsd_briefs_touch_updated_at'
  ) then
    create trigger dsd_briefs_touch_updated_at
      before update on public.dsd_briefs
      for each row
      execute procedure public.touch_updated_at();
  end if;
end$$;

-- 4) cultural_moments
create table if not exists public.cultural_moments (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  description text not null,
  intensity integer not null,
  platforms text[],
  demographics text[],
  duration text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

do $$
begin
  if not exists (
    select 1 from pg_trigger
    where tgname = 'cultural_moments_touch_updated_at'
  ) then
    create trigger cultural_moments_touch_updated_at
      before update on public.cultural_moments
      for each row
      execute procedure public.touch_updated_at();
  end if;
end$$;

-- 5) (Optional) basic RLS – only if you want it now.
--    If you enable RLS, your app MUST be signed in to read/write.
--    Comment these out if you prefer to keep RLS off during smoke tests.

-- alter table public.captures enable row level security;
-- create policy "captures_owner_select"
--   on public.captures for select
--   using (user_id = auth.uid());
-- create policy "captures_owner_insert"
--   on public.captures for insert
--   with check (user_id = auth.uid());

-- alter table public.dsd_briefs enable row level security;
-- create policy "dsd_briefs_owner_select"
--   on public.dsd_briefs for select
--   using (user_id = auth.uid());
-- create policy "dsd_briefs_owner_insert"
--   on public.dsd_briefs for insert
--   with check (user_id = auth.uid());
If you previously had foreign keys to auth.users, you can add them later (we skipped FK constraints here to keep the fix fast and avoid breaking if your auth schema differs).