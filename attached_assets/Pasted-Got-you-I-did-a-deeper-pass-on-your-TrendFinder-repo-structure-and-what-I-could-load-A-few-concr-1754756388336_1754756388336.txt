Got you. I did a deeper pass on your `TrendFinder` repo structure and what I could load. A few concrete, code-level issues + fixes you can apply right now:

# Top risks (fix first)

* **Secrets/cookies committed** — multiple `*cookies*.txt` files are in the root, which can leak auth/session and get endpoints banned. Purge from history (not just delete) and rotate anything they ever touched. ([GitHub][1])
* **Bundled junk in Git** — `attached_assets/` and packaged extension artifacts are versioned; they bloat the repo and break diffs/merges. Move to Releases or ignore. ([GitHub][1])
* **Multi-app repo, no orchestrator** — you’ve got `client/`, `server/`, `chrome-extension/`, plus `shared/`, but no reliable root scripts/CI to build/test all consistently. Add npm workspaces + CI. ([GitHub][1])

# Repo hygiene (apply now)

**.gitignore (add/replace):**

```
# node/build
node_modules/
dist/
build/
.vite/
.cache/

# env/logs/secrets
.env
*.env.*
*.log
*cookie*.txt
cookies.txt

# replit/temp/assets/bundles
.replit
attached_assets/
*.zip
*.tar.gz
*.jar
```

Then:

```bash
git rm -r --cached node_modules dist build .vite .cache attached_assets \
  "*.zip" "*.tar.gz" "*.jar" "*.log" "*cookie*.txt" cookies.txt
git commit -m "chore(repo): untrack build artifacts, logs, and cookies"
# Purge secrets from history (recommended):
# Option A (preferred)
git filter-repo --invert-paths --path-glob "*cookie*.txt" --path cookies.txt
# Option B (BFG)
# bfg --delete-files "*cookie*.txt" --delete-files cookies.txt
git push --force
```

Rotate any tokens/cookies those files contained, immediately. ([GitHub][1])

# Monorepo setup (workspaces + type safety)

Create a root `package.json` with workspaces and common scripts:

```json
{
  "private": true,
  "name": "trendfinder",
  "workspaces": ["server", "client", "chrome-extension", "shared"],
  "scripts": {
    "build": "npm run -ws build",
    "dev": "concurrently -k \"npm:dev-*\"",
    "dev-server": "npm --workspace server run dev",
    "dev-client": "npm --workspace client run dev",
    "lint": "eslint .",
    "typecheck": "tsc -b"
  },
  "devDependencies": {
    "concurrently": "^9.0.0",
    "eslint": "^9.0.0",
    "typescript": "^5.5.0"
  }
}
```

Add a **root tsconfig** (project refs) and `shared/` as a TS project so `server` & `client` import types via path aliases:

```json
// tsconfig.json (root)
{
  "files": [],
  "references": [{ "path": "shared" }, { "path": "server" }, { "path": "client" }]
}
```

# Server (robustness & security)

Even though I couldn’t open individual server files (GitHub UI glitch), your layout + Drizzle config implies a Node/TS API. Here’s what typically bites:

1. **Input validation & error handling**
   Use Zod + a centralized error handler:

```ts
// middleware/validate.ts
import { ZodSchema } from "zod";
export const validate =
  (schema: ZodSchema) =>
  (req, _res, next) => {
    const r = schema.safeParse({ body: req.body, query: req.query, params: req.params });
    if (!r.success) return next(Object.assign(new Error("ValidationError"), { status: 400, zod: r.error }));
    Object.assign(req, r.data);
    next();
  };
```

Add `helmet`, strict `cors`, and a rate limiter on all external-facing routes.

2. **HTTP reliability**
   Wrap all outbound calls (APIs, scrapers) with: per-request **timeout**, **retry with exponential backoff**, and **keep-alive** agents to prevent socket churn:

```ts
import fetch, { RequestInit } from "node-fetch";
import { setTimeout as sleep } from "timers/promises";
import http from "http"; import https from "https";

const httpAgent = new http.Agent({ keepAlive: true });
const httpsAgent = new https.Agent({ keepAlive: true });

export async function safeFetch(url: string, init: RequestInit = {}, attempts = 3) {
  for (let i = 1; i <= attempts; i++) {
    const ctrl = new AbortController();
    const id = setTimeout(() => ctrl.abort(), 15000); // 15s
    try {
      const res = await fetch(url, { ...init, agent: (u=>u.startsWith("https"))(url)?httpsAgent:httpAgent, signal: ctrl.signal });
      clearTimeout(id);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res;
    } catch (e) {
      clearTimeout(id);
      if (i === attempts) throw e;
      await sleep(250 * 2 ** (i - 1) + Math.random() * 200);
    }
  }
}
```

3. **Job isolation**
   If you have scheduled scrapes/analysis, move them into a worker queue (BullMQ + Redis). This avoids Express timeouts and makes retries/metrics sane.

4. **Drizzle**
   Ensure you’re using **migrations** (not `sync`) and that `drizzle-kit` generates to a clean `drizzle/` folder. Add a predeploy step:

```bash
drizzle-kit generate && drizzle-kit migrate
```

# Client (Vite + envs)

* **Use VITE\_ env naming** so only what you intend is exposed:

  * `.env` (server only), `.env.local` (ignored), and `client/.env` with `VITE_` vars.
* **Strict TS**: `"strict": true`, `"noUncheckedIndexedAccess": true`, `"exactOptionalPropertyTypes": true`.
* **Network layer**: one API client with interceptors, request-id header, and user-friendly error mapping.

# Chrome extension (permissions & UX)

You’ve got `chrome-extension/` plus status markdowns indicating active work. Common issues to fix:

* **Minimize permissions** in `manifest.json` (only exact `host_permissions` you truly need). Avoid `"tabs"` unless required.
* **Content-Security-Policy**: if you inject scripts, use `world: 'ISOLATED'` content scripts, avoid `unsafe-eval`.
* **Download flow**: if you save media, prefer the **background service worker** to call `chrome.downloads.download(...)` and message from content script → background.
* **Packaging**: never commit built `.zip` bundles; generate via `npm run build:extension` and attach to Releases.
  Repo clearly shows an extension directory and asset dumps at root; move bundled artifacts out of Git. ([GitHub][1])

# Logging & observability

Adopt **pino** for structured logs and attach a **requestId** to every inbound request and outgoing call. Emit `{ url, status, ms, target }` for every external fetch. This will make rate-limit and timeout diagnosis trivial.

# Testing that gives you leverage

* **Unit**: Vitest for pure logic/utilities in `shared/` and `server`.
* **Integration**: Spin up a test DB instance and run route tests with Supertest.
* **E2E for extension**: Playwright to open a Chromium profile with your extension loaded, click the UI, and assert DOM mutations/download events.
* **Contract tests**: If you call third-party APIs, freeze a few golden responses as fixtures and validate your parsers (so when an API changes, you see it).

# CI that stops regressions

Add a minimal GitHub Action:

```yaml
name: ci
on: [push, pull_request]
jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: 'npm' }
      - run: npm ci
      - run: npm run typecheck
      - run: npm run lint
      - run: npm -w server test --if-present
      - run: npm -w client test --if-present
```

This will cover your TypeScript (89.9% of the repo) and prevent drift across packages. ([GitHub][1])

# Quick checklist (do these in order)

1. Purge `*cookies*.txt` from the entire history and rotate creds. ([GitHub][1])
2. Add the `.gitignore` and untrack artifacts. ([GitHub][1])
3. Introduce npm workspaces, root scripts, and minimal CI.
4. Add input validation + global error handler; wrap all fetches with timeout/retry/keep-alive.
5. Split long-running jobs to a worker; add structured logs with request IDs.
6. Lock down extension permissions + background-driven downloads; stop committing bundles.

If you want, point me at any specific file (e.g., `server/src/index.ts`, `chrome-extension/manifest.json`, or a problematic fetcher), and I’ll propose exact diffs. For now, the structural fixes above will remove a big chunk of instability and make debugging way easier.

[1]: https://github.com/Maz0327/TrendFinder "GitHub - Maz0327/TrendFinder"
