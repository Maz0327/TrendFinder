Alright—if you’re still stuck on a URL like:

https://workspace.maz0327.repl.co/auth/callback#access_token=...

that means the page that should consume the fragment isn’t actually doing it (or never mounts), so the tokens sit in the hash forever. Let’s make the callback bullet-proof by handling the fragment at the app root (so it works even if the route doesn’t render), and by generating the correct redirectTo for either BrowserRouter or HashRouter.

Below is a single, copy-paste Replit Task Runbook that the agent can execute. I’ve added a tiny “human” checklist at the end.

⸻

Replit Task — OAuth Callback: Global Handler + Correct redirectTo

0) Context

Goal: if we land on /auth/callback#access_token=…, we always parse the hash, set the Supabase session, clean the URL, and redirect into the app—even if the callback route fails to render.

⸻

1) Ensure Supabase client can parse URL (keep your current options)

Edit: client/src/lib/supabaseClient.ts (or wherever the client is created)
	•	Ensure these options (do not remove others):

auth: {
  detectSessionInUrl: true,
  persistSession: true,
  autoRefreshToken: true,
}


⸻

2) Add helper to build the correct redirect URL (supports hash & browser routing)

Create: client/src/lib/authRedirect.ts

export function getAuthRedirectUrl(): string {
  const siteUrl = (import.meta.env.VITE_SITE_URL ?? window.location.origin).replace(/\/$/, "");
  // If app uses HashRouter, routes live after "/#/"
  // Detect at runtime to be safe across Replit/localhost
  const usesHash = window.location.href.includes("/#/");
  return usesHash ? `${siteUrl}/#/auth/callback` : `${siteUrl}/auth/callback`;
}


⸻

3) Use that helper for Google sign-in

Find your “Sign in with Google” action (e.g. client/src/pages/Login.tsx or similar) and update:

import { supabase } from "@/integrations/supabase/client";
import { getAuthRedirectUrl } from "@/lib/authRedirect";

const redirectTo = getAuthRedirectUrl();

await supabase.auth.signInWithOAuth({
  provider: "google",
  options: {
    redirectTo,
    queryParams: { access_type: "offline", prompt: "consent" },
  },
});


⸻

4) Add a global OAuth bridge that runs before your routes fully render

This guarantees the hash gets processed even if your specific /auth/callback route doesn’t mount.

Create: client/src/components/auth/OAuthBridge.tsx

import { useEffect, useRef } from "react";
import { supabase } from "@/integrations/supabase/client";

type Cleanup = () => void;

export default function OAuthBridge() {
  const ran = useRef(false);

  useEffect(() => {
    if (ran.current) return;
    ran.current = true;

    const cleanUrl = () => {
      const clean = window.location.pathname + window.location.search;
      window.history.replaceState(null, "", clean);
    };

    const handle = async () => {
      // If we already have a session, nothing to do
      const initial = await supabase.auth.getSession();
      if (initial?.data?.session) return;

      // If URL hash contains tokens, set the session by hand
      const hash = window.location.hash?.startsWith("#") ? window.location.hash.slice(1) : "";
      const params = new URLSearchParams(hash);
      const error = params.get("error");
      const access_token = params.get("access_token");
      const refresh_token = params.get("refresh_token");

      if (error) {
        console.error("OAuth error:", error, {
          error_code: params.get("error_code"),
          error_description: params.get("error_description"),
        });
        cleanUrl();
        return;
      }

      if (access_token && refresh_token) {
        try {
          const { error: setErr } = await supabase.auth.setSession({
            access_token,
            refresh_token,
          });
          if (setErr) {
            console.error("setSession error:", setErr);
          } else {
            // Success: clean the hash
            cleanUrl();
          }
        } catch (e) {
          console.error("setSession exception:", e);
          cleanUrl();
        }
        return;
      }

      // As a fallback, listen briefly for Supabase to hydrate automatically
      const { data: sub } = supabase.auth.onAuthStateChange((_event, session) => {
        if (session) {
          cleanUrl();
        }
      });

      setTimeout(async () => {
        sub.subscription.unsubscribe();
        const again = await supabase.auth.getSession();
        if (again?.data?.session) {
          cleanUrl();
        }
      }, 1500);
    };

    handle();
  }, []);

  // This component renders nothing; it just runs once on app boot.
  return null;
}

Mount it at the very top of your app, outside any ProtectedRoute:

Edit: client/src/App.tsx (or your main layout/root component)

import OAuthBridge from "@/components/auth/OAuthBridge";

// Inside your root component JSX:
<>
  <OAuthBridge />
  {/* your existing layout + routes */}
</>

This way, even if /auth/callback route is misconfigured, the bridge runs at app boot and cleans/redirects.

⸻

5) Keep a simple, public /auth/callback route (belt & suspenders)

Create/Edit: client/src/pages/AuthCallback.tsx

import { useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { supabase } from "@/integrations/supabase/client";

export default function AuthCallback() {
  const navigate = useNavigate();

  useEffect(() => {
    // If we already have a session here, just go home:
    supabase.auth.getSession().then(({ data }) => {
      if (data?.session) {
        navigate("/", { replace: true });
      } else {
        // If OAuthBridge already handled, hash will be empty and app’s guards will take over.
        navigate("/", { replace: true });
      }
    });
  }, [navigate]);

  return (
    <div className="w-full min-h-[40vh] flex items-center justify-center text-sm text-muted-foreground">
      Finishing sign-in…
    </div>
  );
}

Ensure the route is public in your router:

<Route path="/auth/callback" element={<AuthCallback />} />


⸻

6) Double-check router type (Browser vs Hash)
	•	If you use HashRouter, the correct redirect must include /#/auth/callback. Our getAuthRedirectUrl() already handles that.
	•	If you use BrowserRouter, you’ll get /auth/callback. Also handled.

No further changes needed.

⸻

7) Quick sanity checks
	•	npm run build → should pass.
	•	Start the app → click Sign in with Google → you will briefly see #access_token=…, then it clears and the app redirects in (session established).

⸻

HUMAN CHECKLIST (dashboard config)

You probably already did these, but confirm:
	1.	Supabase → Authentication → URL Configuration
	•	Site URL: https://workspace.maz0327.repl.co
	2.	Supabase → Authentication → Providers → Google
	•	Redirect URLs include:
	•	https://workspace.maz0327.repl.co/auth/callback
	•	http://localhost:5173/auth/callback
	3.	Google Cloud Console → OAuth Client
	•	Authorized redirect URIs include both:
	•	https://workspace.maz0327.repl.co/auth/callback
	•	http://localhost:5173/auth/callback
	•	Your Google account is added as a Test user (if app is still in Testing).
	4.	Replit Secrets
	•	VITE_SITE_URL = https://workspace.maz0327.repl.co
	•	VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY set as before.

⸻

Why this will fix it
	•	If your callback route doesn’t mount for any reason, OAuthBridge still runs at app boot, sees the fragment, calls setSession(), and cleans the URL.
	•	If your router uses hash-based routing, redirectTo automatically targets /#/auth/callback.
	•	If Supabase auto-parsing succeeds before our bridge, nothing breaks; our code is idempotent.
	•	This pattern is resilient on Replit / custom domains where route mounting order or guards can get finicky.

Give this a go—once it’s in, you shouldn’t ever get stuck on that hash URL again.