Replit Agent ‚Äì Phase 5 Run Sheet (Do in order)
0) Prep
bash
Copy
Edit
git pull || true
1) Harden HTTP security headers
File: server/routes.ts (or server/index.ts ‚Äî whichever creates the Express app)

Add these imports at the top (keep existing ones):

ts
Copy
Edit
import helmet from "helmet";
Immediately after const app = express(); add:

ts
Copy
Edit
app.use(helmet({
  crossOriginResourcePolicy: { policy: "cross-origin" },
  contentSecurityPolicy: {
    useDefaults: true,
    directives: {
      "default-src": ["'self'"],
      "script-src": ["'self'", "'unsafe-inline'"],
      "style-src": ["'self'", "'unsafe-inline'"],
      "img-src": ["'self'", "data:", "blob:"],
      "connect-src": ["'self'", process.env.SUPABASE_URL || ""],
      "frame-ancestors": ["'self'"]
    }
  },
  referrerPolicy: { policy: "no-referrer" },
  frameguard: { action: "sameorigin" }
}));
2) Centralize secret usage + block service role on client
File: server/config.ts (create if missing)

ts
Copy
Edit
export const CONFIG = {
  SUPABASE_URL: process.env.SUPABASE_URL!,
  SUPABASE_ANON_KEY: process.env.SUPABASE_ANON_KEY!,
  SUPABASE_JWT_SECRET: process.env.SUPABASE_JWT_SECRET!,
  // Never expose service role key to client
  SUPABASE_SERVICE_ROLE_KEY: process.env.SUPABASE_SERVICE_ROLE_KEY || "",
};
File: client/src/lib/env.ts (create)

ts
Copy
Edit
export const CLIENT_ENV = {
  SUPABASE_URL: import.meta.env.VITE_SUPABASE_URL as string,
  SUPABASE_ANON_KEY: import.meta.env.VITE_SUPABASE_ANON_KEY as string,
};
// No service role key on client ‚Äì do not add it here.
Search & remove any usage of SUPABASE_SERVICE_ROLE_KEY under client/:

bash
Copy
Edit
grep -Rni "SERVICE_ROLE" client || true
If found, delete those client references and keep service-role usage server-only.

3) Add request body size + JSON limit
File: server/routes.ts (or server entry where app.use(express.json()) is)
Replace the JSON/body parser with:

ts
Copy
Edit
app.use(express.json({ limit: "512kb" }));
app.use(express.urlencoded({ limit: "512kb", extended: true }));
4) Strict input sanitization middleware (already exists, enforce on all POST/PATCH)
File: server/middleware/sanitization.ts
Ensure this default export exists:

ts
Copy
Edit
import { sanitizeInput } from "../utils/sanitize";

export function sanitizeBody(req, _res, next) {
  if (req.body && typeof req.body === "object") {
    for (const k of Object.keys(req.body)) {
      const v = req.body[k];
      if (typeof v === "string") req.body[k] = sanitizeInput(v);
    }
  }
  next();
}
File: server/routes.ts
Apply to all mutating routes before handlers:

ts
Copy
Edit
import { sanitizeBody } from "./middleware/sanitization";

// Apply globally for POST/PATCH
app.post("*", sanitizeBody);
app.patch("*", sanitizeBody);
5) Data retention controls (auto-delete old captures)
File: server/jobs/data-retention.ts (create)

ts
Copy
Edit
import { storage } from "../storage";

const DAYS = Number(process.env.DATA_RETENTION_DAYS || "90");

export async function purgeOldCaptures() {
  const cutoff = new Date(Date.now() - DAYS * 24 * 60 * 60 * 1000).toISOString();
  try {
    const deleted = await storage.deleteCapturesOlderThan(cutoff);
    console.log(`[RETENTION] Deleted ${deleted} captures older than ${DAYS} days`);
  } catch (e) {
    console.error("[RETENTION] purge failed:", e);
  }
}

export function scheduleDataRetention() {
  // run every 12h
  setInterval(purgeOldCaptures, 12 * 60 * 60 * 1000);
  // run once at boot
  purgeOldCaptures();
}
File: server/storage.ts
Add method (place near other capture methods):

ts
Copy
Edit
async deleteCapturesOlderThan(isoCutoff: string): Promise<number> {
  const { data, error, count } = await this.client
    .from("captures")
    .delete({ count: "exact" })
    .lt("created_at", isoCutoff);

  if (error) throw error;
  return count || 0;
}
File: server/routes.ts (or server entry after app + storage init)

ts
Copy
Edit
import { scheduleDataRetention } from "./jobs/data-retention";
scheduleDataRetention();
File: .env (or Replit Secrets)
Add (if not present):

ini
Copy
Edit
DATA_RETENTION_DAYS=90
6) PII/secret redaction in logs
File: server/utils/logger.ts (create)

ts
Copy
Edit
export function redact(obj: any) {
  const clone = JSON.parse(JSON.stringify(obj || {}));
  const keys = ["password","token","access_token","refresh_token","apikey","api_key","authorization","cookie"];
  const walk = (o: any) => {
    if (!o || typeof o !== "object") return;
    for (const k of Object.keys(o)) {
      if (keys.includes(k.toLowerCase())) o[k] = "***REDACTED***";
      else walk(o[k]);
    }
  };
  walk(clone);
  return clone;
}

export const log = {
  info: (...a: any[]) => console.log(...a.map(redact)),
  warn: (...a: any[]) => console.warn(...a.map(redact)),
  error: (...a: any[]) => console.error(...a.map(redact)),
};
Replace any console.log/warn/error in server with log.info/warn/error (skip if many, but ensure new code uses log).

7) Chrome Extension ‚Äì restrict permissions
File: extension/manifest.json
Replace these blocks exactly:

Permissions

json
Copy
Edit
"permissions": ["storage", "scripting", "activeTab"],
Host permissions (narrowed)

json
Copy
Edit
"host_permissions": [
  "https://*.twitter.com/*",
  "https://*.tiktok.com/*",
  "https://*.instagram.com/*",
  "https://*.reddit.com/*",
  "https://*.linkedin.com/*",
  "https://*.youtube.com/*"
],
"optional_host_permissions": [
  "https://*/*",
  "http://*/*"
],
Background (service worker remains)
Do not add "*://*/*" to "permissions".

8) Privacy Notice (in-app + extension)
File: client/src/pages/privacy.tsx (create)

tsx
Copy
Edit
export default function Privacy() {
  return (
    <div className="p-6 max-w-3xl mx-auto space-y-4">
      <h1 className="text-2xl font-bold">Privacy & Data Use</h1>
      <p>We collect content you explicitly capture and metadata needed to analyze trends.</p>
      <ul className="list-disc pl-6">
        <li>We do not sell your data.</li>
        <li>You can delete your captures at any time.</li>
        <li>Data older than {import.meta.env.VITE_DATA_RETENTION_DAYS || 90} days may be deleted automatically.</li>
      </ul>
      <p>Questions? Contact support.</p>
    </div>
  );
}
File: client/src/main.tsx or router config ‚Äî add a route /privacy to render this page.

File: extension/options.html (create simple static info)

html
Copy
Edit
<!doctype html>
<html><body>
  <h2>Privacy</h2>
  <p>This extension only captures pages when you click ‚ÄúCapture‚Äù. No background collection.</p>
  <p>Data is sanitized client-side and sent securely to the app.</p>
</body></html>
File: extension/manifest.json ‚Äî add:

json
Copy
Edit
"options_page": "options.html"
9) Block dangerous HTML in AI prompts (server-side)
File: server/services/capture-analysis-service.ts
Before sending any captured content to an AI model, ensure:

ts
Copy
Edit
import { sanitizeInput } from "../utils/sanitize";
// ...
const cleanContent = sanitizeInput(rawContent || "");
Replace any usage of raw content with cleanContent.

10) Enforce auth on Google exports & remove session tokens
File: server/routes/google-exports.ts

Ensure the router uses your requireAuth middleware for every route in this file.

Remove all req.session.googleTokens storage. Instead expect tokens coming from the client per-request if you still need Google features, or disable the feature:

Temporarily return 501:

ts
Copy
Edit
res.status(501).json({ error: "Google export temporarily disabled pending OAuth storage redesign." });
Do this at the top of each handler to block accidental token persistence.

11) Validate all POST/PATCH via zod
File: server/middleware/validate.ts (create)

ts
Copy
Edit
import { ZodSchema } from "zod";
export const validateBody = (schema: ZodSchema) => (req, res, next) => {
  const r = schema.safeParse(req.body);
  if (!r.success) return res.status(400).json({ error: "Invalid body", details: r.error.issues });
  req.body = r.data;
  next();
};
Example usage (one route)
File: server/routes/captures.ts (or wherever POST /api/captures lives)

ts
Copy
Edit
import { z } from "zod";
import { validateBody } from "../middleware/validate";

const CreateCapture = z.object({
  content: z.string().min(1),
  platform: z.string().optional(),
  url: z.string().url().optional(),
});

router.post("/api/captures", requireAuth, validateBody(CreateCapture), async (req, res) => {
  // handler...
});
(Apply progressively to other mutating routes; if time is short, do captures + analysis first.)

12) Final checks
bash
Copy
Edit
npm run build || true
npx tsc --noEmit
npm run dev & sleep 2; kill %1 || true
If tsc is clean and dev boots, commit:

bash
Copy
Edit
git add -A
git commit -m "Phase 5: security/privacy hardening (helmet, retention, redaction, perms, validators)"
git push
Want me to generate a tiny todo report the agent can print at the end (what it changed & any files it skipped)?










Sources
You said:
yes


ChatGPT said:
Got it ‚Äî I‚Äôll append a Phase 5 Agent Todo Report Generator step at the end so the Replit Agent can summarize exactly what it touched or skipped.

Here‚Äôs the updated end of Phase 5 run sheet for the agent:

12) Final checks
bash
Copy
Edit
npm run build || true
npx tsc --noEmit
npm run dev & sleep 2; kill %1 || true
If tsc is clean and dev boots, commit:

bash
Copy
Edit
git add -A
git commit -m "Phase 5: security/privacy hardening (helmet, retention, redaction, perms, validators)"
git push
13) Generate Agent Todo Report
At the end of execution, output this exactly:

Phase 5 ‚Äì Security/Privacy Hardening Report

‚úÖ List all files created (with paths)

‚úÖ List all files modified (with paths)

‚ö†Ô∏è List any files skipped or not found

üîÑ Summarize changes in one paragraph (max 4 sentences)

üìå Mark any TODOs for future (e.g., routes not yet wrapped in zod validator)

Example format the agent should print:

bash
Copy
Edit
Phase 5 ‚Äì Security/Privacy Hardening Report
Files created:
- server/config.ts
- client/src/lib/env.ts
- server/jobs/data-retention.ts
- server/utils/logger.ts
Files modified:
- server/routes.ts
- extension/manifest.json
Skipped / not found:
- server/routes/google-exports.ts (not present)
Summary:
Implemented helmet, retention jobs, redaction logger, narrowed extension permissions, enforced sanitization middleware, and added privacy pages. All .env keys scoped correctly with no service-role leak to client. Data retention job running on schedule. Remaining TODO: wrap all mutating routes in zod validation.