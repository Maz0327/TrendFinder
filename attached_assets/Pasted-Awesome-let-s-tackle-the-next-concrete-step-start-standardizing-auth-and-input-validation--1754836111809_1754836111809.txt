Awesome â€” letâ€™s tackle the next concrete step: start standardizing **auth** and **input validation** on a couple of high-traffic routes. Weâ€™ll do this in tiny, safe chunks so you can paste exactly whatâ€™s needed.

Weâ€™ll update **two routes in `server/routes.ts`**:

1. `GET /api/captures` â†’ use JWT auth middleware (`requireAuth`)
2. `POST /api/extension/capture` â†’ use JWT auth + Zod validation (`validateBody`)

If you havenâ€™t added the two small middleware files yet, do Steps 1â€“2. If you already added them earlier, skip to Step 3.

---

## Step 1 â€” Create auth middleware (once)

**Create file:** `server/middleware/auth.ts`
**Paste this EXACT content:**

```ts
import { Request, Response, NextFunction } from "express";
import jwt from "jsonwebtoken";

export interface AuthedUser {
  id: string;
  email?: string;
}

export interface AuthedRequest extends Request {
  user?: AuthedUser;
}

const SUPABASE_JWT_SECRET = process.env.SUPABASE_JWT_SECRET || "";

export function requireAuth(req: AuthedRequest, res: Response, next: NextFunction) {
  const header = req.headers.authorization || "";
  const token = header.startsWith("Bearer ") ? header.slice(7) : null;

  if (!token) {
    return res.status(401).json({ error: "Not authenticated" });
  }

  try {
    const payload = jwt.verify(token, SUPABASE_JWT_SECRET) as any;
    // Supabase JWT typically provides sub (user id), email
    req.user = { id: payload.sub, email: payload.email };
    next();
  } catch (err) {
    return res.status(401).json({ error: "Invalid token" });
  }
}
```

---

## Step 2 â€” Create validation helpers (once)

**Create file:** `server/middleware/validate.ts`
**Paste this EXACT content:**

```ts
import { z, ZodSchema } from "zod";
import { Request, Response, NextFunction } from "express";

export function validateBody<T>(schema: ZodSchema<T>) {
  return (req: Request, res: Response, next: NextFunction) => {
    const parsed = schema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid input", details: parsed.error.errors });
    }
    req.body = parsed.data;
    next();
  };
}

export function validateQuery<T>(schema: ZodSchema<T>) {
  return (req: Request, res: Response, next: NextFunction) => {
    const parsed = schema.safeParse(req.query);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid query", details: parsed.error.errors });
    }
    req.query = parsed.data as any;
    next();
  };
}

export const zod = z;
```

---

## Step 3 â€” Update `GET /api/captures` to require JWT auth

**Open file:** `server/routes.ts`
**At the top of the file (with other imports), ADD these imports (do not remove anything else):**

```ts
import { requireAuth, AuthedRequest } from "./middleware/auth";
import { validateBody, zod as z } from "./middleware/validate";
```

**Find the existing handler for `GET /api/captures`**. It currently looks like this (begins with a session check):

```ts
app.get("/api/captures", async (req, res) => {
  try {
    if (!req.session?.user?.id) {
      return res.status(401).json({ error: "Not authenticated" });
    }
    
    const captures = await db.getUserCaptures(req.session.user.id);
    res.json(captures);
  } catch (error) {
    console.error("Error fetching user captures:", error);
    res.status(500).json({ error: "Failed to fetch captures" });
  }
});
```

**REPLACE that entire block with this EXACT code:**

```ts
app.get("/api/captures", requireAuth, async (req: AuthedRequest, res) => {
  try {
    const userId = req.user!.id;
    const captures = await db.getUserCaptures(userId);
    res.json(captures);
  } catch (error) {
    console.error("Error fetching user captures:", error);
    res.status(500).json({ error: "Failed to fetch captures" });
  }
});
```

That removes session dependency and uses `req.user.id` from the JWT.

---

## Step 4 â€” Update `POST /api/extension/capture` to use JWT + Zod validation

**Find the existing handler for `POST /api/extension/capture`**. It currently begins like this:

```ts
app.post("/api/extension/capture", async (req, res) => {
  try {
    if (!req.session?.user?.id) {
      return res.status(401).json({ error: "Not authenticated" });
    }

    const { projectId, content, url, platform, type = "extension", priority = "normal" } = req.body;
    ...
```

**REPLACE that entire handler with this EXACT code:**

```ts
const extensionCaptureSchema = z.object({
  projectId: z.string().uuid().optional(),
  content: z.string().min(1),
  url: z.string().url().optional(),
  platform: z.string().optional(),
  type: z.string().optional().default("extension"),
  priority: z.enum(["low", "normal", "high"]).optional().default("normal"),
});

app.post(
  "/api/extension/capture",
  requireAuth,
  validateBody(extensionCaptureSchema),
  async (req: AuthedRequest, res) => {
    try {
      const { projectId, content, url, platform, type, priority } = req.body as z.infer<typeof extensionCaptureSchema>;

      // Track extension request
      const extensionId = req.headers["x-extension-id"] as string | undefined;
      if (extensionId) {
        productionMonitor.trackExtensionRequest(extensionId);
      }

      console.log(`ðŸ“± Extension capture from ${platform || "unknown"}: ${content.substring(0, 50)}...`);

      // Create the capture (fallback to first project if projectId missing)
      const userId = req.user!.id;
      const fallbackProjectId = (await storage.getProjects(userId))[0]?.id;
      const capture = await storage.createCapture({
        userId,
        projectId: projectId || fallbackProjectId,
        type: type || "extension",
        content,
        url,
        platform: platform || "web",
        title: `Extension Capture - ${new Date().toLocaleString()}`,
        priority,
        analysisStatus: "pending",
      });

      // Trigger analysis if content is substantial
      if (content.length > 50) {
        try {
          const analysis = await aiAnalyzer.analyzeContent("Extension Capture", content, platform || "web");
          await storage.updateCapture(capture.id, {
            viralScore: analysis.viralScore,
            analysisStatus: "completed",
          });
        } catch (analysisError) {
          console.warn("Analysis failed for extension capture:", analysisError);
        }
      }

      res.json({
        success: true,
        capture: {
          id: capture.id,
          title: capture.title,
          createdAt: capture.createdAt,
        },
      });
    } catch (error) {
      console.error("Extension capture error:", error);

      // Track extension error
      const extensionId = req.headers["x-extension-id"] as string | undefined;
      if (extensionId) {
        productionMonitor.trackExtensionRequest(
          extensionId,
          error instanceof Error ? error.message : "Unknown error"
        );
      }

      res.status(500).json({
        error: "Failed to create capture",
        details: error instanceof Error ? error.message : "Unknown error",
      });
    }
  }
);
```

This does three things:

* Requires a valid `Authorization: Bearer <supabase_jwt>` header
* Validates the request body (so missing or malformed inputs return a clean 400 with details)
* Keeps the existing analysis trigger logic as-is

---

## Step 5 â€” Test

1. **Restart dev server** in Replit:

```bash
npm run dev
```

2. **Smoke test the two routes**:

* Open the app and try loading your captures list (the app should include a token in requests; if not, weâ€™ll wire that next).
* Use your extension (or a REST client like Thunder Client/Postman) to hit `POST /api/extension/capture` with a valid JWT and a simple JSON body:

  ```json
  {
    "content": "Hello world from extension test",
    "platform": "web"
  }
  ```

3. **If you get 401** on either route, that means the front-end isnâ€™t sending the Supabase JWT yet. Say the word and Iâ€™ll give you the exact front-end change to attach the token automatically to all `/api/*` requests.

---

If you want, next we can:

* Convert `GET /api/captures/recent` and `GET /api/captures/all` the same way (quick copy/paste).
* Start moving one heavy AI route to the job queue (Iâ€™ll give you an exact cut-over for `/api/ai/quick-analysis`).

Tell me when these two handlers are updated and running, and weâ€™ll proceed.
