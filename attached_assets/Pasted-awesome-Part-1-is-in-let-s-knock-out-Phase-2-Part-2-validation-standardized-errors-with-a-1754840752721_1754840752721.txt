awesome—Part 1 is in. let’s knock out **Phase 2 – Part 2** (validation + standardized errors) with agent-friendly, paste-ready steps.

---

# Phase 2 – Part 2 (Agent-ready)

## Step 1 — Add tiny validation helpers

**Create file:** `server/middleware/validate.ts`
**PASTE EXACTLY:**

```ts
import { z, ZodSchema } from "zod";
import type { Request, Response, NextFunction } from "express";

export function validateBody<T>(schema: ZodSchema<T>) {
  return (req: Request, res: Response, next: NextFunction) => {
    const result = schema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ error: "Invalid body", details: result.error.errors });
    }
    // @ts-expect-error augment for downstream handlers
    req.validated = { ...(req as any).validated, body: result.data };
    next();
  };
}

export function validateQuery<T>(schema: ZodSchema<T>) {
  return (req: Request, res: Response, next: NextFunction) => {
    const result = schema.safeParse(req.query);
    if (!result.success) {
      return res.status(400).json({ error: "Invalid query", details: result.error.errors });
    }
    // @ts-expect-error augment for downstream handlers
    req.validated = { ...(req as any).validated, query: result.data };
    next();
  };
}

// Optional: types you can use in handlers
export type ValidatedRequest<TBody = unknown, TQuery = unknown> = Request & {
  validated?: { body?: TBody; query?: TQuery };
};
```

---

## Step 2 — Add Zod schemas and wire them into **existing routes** (surgical patches)

> All edits below happen in `server/routes.ts`. If a route was moved into a router already, apply the change in that router file instead (I’ll call that out explicitly).

### 2A) `/api/ai/analyze` (body validation)

**FIND the whole handler for** `app.post("/api/ai/analyze", ...`
**REPLACE it with EXACTLY:**

```ts
import { z } from "zod";
import { validateBody, ValidatedRequest } from "./middleware/validate";

const aiAnalyzeSchema = z.object({
  content: z.string().min(1),
  type: z.string().optional(),
  platform: z.string().optional(),
});

app.post("/api/ai/analyze", requireAuth, validateBody(aiAnalyzeSchema), async (req: ValidatedRequest<z.infer<typeof aiAnalyzeSchema>>, res) => {
  try {
    const { content, type, platform } = req.validated!.body!;
    const analysis = {
      summary: `Strategic analysis of ${type || "content"}: ${content.substring(0, 100)}...`,
      sentiment: Math.random() > 0.6 ? "positive" : Math.random() > 0.3 ? "neutral" : "negative",
      viralScore: Math.floor(Math.random() * 40) + 60,
      strategicValue: Math.floor(Math.random() * 5) + 6,
      keyInsights: [
        "Strong engagement potential detected",
        "Aligns with current trending topics",
        "Recommended for strategic amplification",
      ],
      recommendations: [
        `Optimize for ${platform || "social media"} platform`,
        "Consider cross-platform distribution",
        "Monitor performance metrics closely",
      ],
      targetAudience: { primary: "Digital natives", secondary: "Content creators", engagement: "High" },
    };
    res.json(analysis);
  } catch (error) {
    console.error("Error in AI analysis:", error);
    res.status(500).json({ error: "Failed to analyze content" });
  }
});
```

### 2B) `/api/ai/hook-generator` (body validation)

**FIND the whole handler for** `app.post("/api/ai/hook-generator", ...`
**REPLACE it with EXACTLY:**

```ts
const hookGenSchema = z.object({
  content: z.string().min(1),
  platform: z.string().optional(),
  targetAudience: z.string().optional(),
  tone: z.string().optional(),
});

app.post("/api/ai/hook-generator", requireAuth, validateBody(hookGenSchema), async (req: ValidatedRequest<z.infer<typeof hookGenSchema>>, res) => {
  try {
    const { content, platform, targetAudience, tone } = req.validated!.body!;
    const hooks = [
      `🔥 You won't believe what ${targetAudience || "people"} are saying about this...`,
      `STOP scrolling! This ${platform || "content"} insight will change everything`,
      `The secret that ${targetAudience || "everyone"} doesn't want you to know`,
      `Why ${content.substring(0, 30)}... is trending everywhere`,
      `This simple trick is breaking the internet right now`,
      `${targetAudience || "People"} are going crazy over this new discovery`,
      `Warning: This ${platform || "content"} hack is too powerful`,
      `The ${tone || "authentic"} truth about what's happening`,
      `Everyone is talking about this, but here's what they missed`,
      `This changes everything we thought we knew about ${platform || "content"}`,
    ];
    res.json({
      hooks: hooks.slice(0, 5),
      metadata: {
        platform: platform || "general",
        targetAudience: targetAudience || "general",
        tone: tone || "engaging",
        optimizedFor: "maximum engagement",
      },
      performance: {
        expectedCTR: `${Math.floor(Math.random() * 5) + 3}%`,
        viralPotential: Math.floor(Math.random() * 30) + 70,
        audienceMatch: Math.floor(Math.random() * 20) + 80,
      },
    });
  } catch (error) {
    console.error("Error generating hooks:", error);
    res.status(500).json({ error: "Failed to generate hooks" });
  }
});
```

### 2C) `/api/intelligence/fetch` (body validation)

**FIND the whole handler for** `app.post("/api/intelligence/fetch", ...`
**REPLACE it with EXACTLY:**

```ts
const intelFetchSchema = z.object({
  platforms: z.array(z.string()).min(1),
  keywords: z.array(z.string()).optional().default([]),
  competitors: z.array(z.string()).optional().default([]),
  timeWindow: z.string().optional().default("24h"),
  limit: z.number().int().min(1).max(200).optional().default(50),
});

app.post("/api/intelligence/fetch", requireAuth, validateBody(intelFetchSchema), async (req: ValidatedRequest<z.infer<typeof intelFetchSchema>>, res) => {
  try {
    const { platforms, keywords, competitors, timeWindow, limit } = req.validated!.body!;
    const signals = await strategicIntelligence.fetchMultiPlatformIntelligence({
      platforms,
      keywords,
      competitors,
      timeWindow,
      limit,
    });
    res.json({ success: true, count: signals.length, signals });
  } catch (error) {
    console.error("Error fetching intelligence:", error);
    res.status(500).json({ error: "Failed to fetch intelligence", details: error instanceof Error ? error.message : "Unknown error" });
  }
});
```

### 2D) `/api/bright-data/fetch` (body validation)

**FIND the whole handler for** `app.post("/api/bright-data/fetch", ...`
**REPLACE it with EXACTLY:**

```ts
const brightFetchSchema = z.object({
  platform: z.string().min(1),
  keywords: z.array(z.string()).optional().default([]),
  limit: z.number().int().min(1).max(100).optional().default(20),
});

app.post("/api/bright-data/fetch", requireAuth, validateBody(brightFetchSchema), async (req: ValidatedRequest<z.infer<typeof brightFetchSchema>>, res) => {
  try {
    const { platform, keywords, limit } = req.validated!.body!;
    const data = await fixedBrightData.fetchPlatformData(platform, keywords, limit);
    res.json({ success: true, platform, count: data.length, data, method: data[0]?.metadata?.source || "unknown" });
  } catch (error) {
    console.error("Error fetching via fixed Bright Data:", error);
    res.status(500).json({ error: "Failed to fetch data", details: error instanceof Error ? error.message : "Unknown error", platform: (req.validated?.body as any)?.platform });
  }
});
```

### 2E) `/api/bright-data/live` (body validation)

**FIND the whole handler for** `app.post("/api/bright-data/live", ...`
**REPLACE it with EXACTLY:**

```ts
const brightLiveSchema = z.object({
  platform: z.string().min(1),
  keywords: z.array(z.string()).optional().default([]),
  limit: z.number().int().min(1).max(50).optional().default(20),
});

app.post("/api/bright-data/live", requireAuth, validateBody(brightLiveSchema), async (req: ValidatedRequest<z.infer<typeof brightLiveSchema>>, res) => {
  try {
    const { platform, keywords, limit } = req.validated!.body!;
    const result = await liveBrightData.fetchLiveData(platform, keywords, limit);
    res.json(result);
  } catch (error) {
    console.error("Error fetching live data:", error);
    res.status(500).json({ error: "Failed to fetch live data", details: error instanceof Error ? error.message : "Unknown error", platform: (req.validated?.body as any)?.platform });
  }
});
```

### 2F) `/api/captures/search` (body validation)

**FIND the whole handler for** `app.post("/api/captures/search", ...`
**REPLACE it with EXACTLY:**

```ts
const capturesSearchSchema = z.object({
  query: z.string().optional(),
  platforms: z.array(z.string()).optional(),
  tags: z.array(z.string()).optional(),
  dateRange: z.object({
    from: z.string().datetime().optional(),
    to: z.string().datetime().optional(),
  }).optional(),
});

app.post("/api/captures/search", requireAuth, validateBody(capturesSearchSchema), async (req: ValidatedRequest<z.infer<typeof capturesSearchSchema>>, res) => {
  try {
    const { query, platforms, tags } = req.validated!.body!;
    const captures = await storage.getUserCaptures(req.user!.id);

    let filtered = captures;

    if (query) {
      const q = query.toLowerCase();
      filtered = filtered.filter((c: any) =>
        c.title?.toLowerCase().includes(q) ||
        c.content?.toLowerCase().includes(q) ||
        c.summary?.toLowerCase().includes(q)
      );
    }

    if (platforms && platforms.length > 0 && !platforms.includes("all")) {
      filtered = filtered.filter((c: any) => platforms.includes(c.platform));
    }

    if (tags && tags.length > 0) {
      filtered = filtered.filter((c: any) => tags.some((t: string) => c.tags?.includes(t)));
    }

    res.json({ results: filtered, total: filtered.length, query: req.validated!.body! });
  } catch (error) {
    console.error("Error searching captures:", error);
    res.status(500).json({ error: "Failed to search captures" });
  }
});
```

### 2G) `/api/truth-analysis/analyze` (body validation)

**FIND the whole handler for** `app.post("/api/truth-analysis/analyze", ...`
**REPLACE it with EXACTLY:**

```ts
const truthAnalyzeSchema = z.object({
  content: z.string().min(1),
  platform: z.string().min(1),
  metadata: z.record(z.any()).optional().default({}),
});

app.post("/api/truth-analysis/analyze", requireAuth, validateBody(truthAnalyzeSchema), async (req: ValidatedRequest<z.infer<typeof truthAnalyzeSchema>>, res) => {
  try {
    const { content, platform, metadata } = req.validated!.body!;
    const analysis = await truthFramework.analyzeContent(content, platform, metadata);
    res.json(analysis);
  } catch (error) {
    console.error("Error in truth analysis:", error);
    res.status(500).json({ error: "Failed to analyze content", details: error instanceof Error ? error.message : "Unknown error" });
  }
});
```

> `/api/content` already uses `insertContentRadarSchema`; keep that.

---

## Step 3 — Standardize the global error handler with the logger

**Open:** `server/routes.ts`
**FIND the existing final error middleware block that starts with:**

```ts
// Enhanced error logging middleware
app.use((err: any, req: any, res: any, next: any) => {
  ...
});
```

**REPLACE that entire block with EXACTLY:**

```ts
import { logger } from "./logger";

// Standardized error handler (must be last)
app.use((err: any, req: any, res: any, _next: any) => {
  const status = typeof err.status === "number" ? err.status : 500;
  const code = err.code || "INTERNAL_ERROR";

  logger.error({
    msg: err.message || "Unhandled error",
    code,
    status,
    endpoint: `${req.method} ${req.path}`,
    stack: process.env.NODE_ENV !== "production" ? err.stack : undefined,
  });

  if (!res.headersSent) {
    return res.status(status).json({
      error: err.message || "Internal server error",
      code,
      ...(process.env.NODE_ENV !== "production" ? { details: err.stack } : {}),
    });
  }
});
```

---

## Step 4 — Typecheck and run

**Replit shell:**

```bash
npm run typecheck || npx tsc --noEmit
npm run dev
```

**Quick UI checks:**

* Dashboard loads captures ✅
* Search captures works (send `{ "query": "..." }`) ✅
* Run `POST /api/ai/analyze` with a small body → returns JSON ✅
* Run `POST /api/bright-data/fetch` with `{ "platform":"reddit" }` (or whichever you have wired) → returns JSON ✅

---

If anything fails, paste the **exact error text** and file/line and I’ll give you a pinpoint patch.

When this passes, say “**done Part 2**” and I’ll hand you **Part 3** (centralized request logging + 1-click route splitting template for the `/api/ai/*` and `/api/bright-data/*` groups).
