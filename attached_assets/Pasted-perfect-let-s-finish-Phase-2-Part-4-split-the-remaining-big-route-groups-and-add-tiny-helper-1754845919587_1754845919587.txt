perfect. let’s finish **Phase 2 – Part 4**: split the remaining big route groups and add tiny helpers for config + problem-details responses. all steps are agent-ready, copy/paste exact code.

---

# Phase 2 – Part 4 (agent-ready)

## Step 0 — Add a tiny config helper

**Create file:** `server/config.ts`
**PASTE EXACTLY:**

```ts
export const config = {
  env: process.env.NODE_ENV || "development",
  port: Number(process.env.PORT || 5000),
  logLevel: process.env.LOG_LEVEL || "info",
  supabase: {
    url: process.env.SUPABASE_URL || "",
    anonKey: process.env.SUPABASE_ANON_KEY || "",
  },
};
```

> (We won’t wire this everywhere yet; it’s handy for future steps.)

---

## Step 1 — Add a problem-details helper

**Create file:** `server/utils/problem.ts`
**PASTE EXACTLY:**

```ts
import type { Response } from "express";

type Extras = Record<string, unknown> | undefined;

export function problem(res: Response, status: number, title: string, details?: string, code?: string, extras?: Extras) {
  return res.status(status).json({
    error: title,
    code: code || statusToCode(status),
    details,
    ...extras,
  });
}

function statusToCode(status: number): string {
  switch (status) {
    case 400: return "BAD_REQUEST";
    case 401: return "UNAUTHORIZED";
    case 403: return "FORBIDDEN";
    case 404: return "NOT_FOUND";
    case 409: return "CONFLICT";
    case 422: return "UNPROCESSABLE";
    default: return "INTERNAL_ERROR";
  }
}
```

---

## Step 2 — Split **/api/intelligence/** routes into their own router

**Create file:** `server/routes/intelligence.ts`
**PASTE EXACTLY:**

```ts
import { Router, Response } from "express";
import { requireAuth, AuthedRequest } from "../middleware/auth";
import { z } from "zod";
import { validateBody, ValidatedRequest, validateQuery } from "../middleware/validate";
import { storage } from "../storage";
import { StrategicIntelligenceService } from "../services/strategicIntelligenceService";
import { problem } from "../utils/problem";

export const intelligenceRouter = Router();

const strategicIntelligence = new StrategicIntelligenceService(storage);

// POST /api/intelligence/fetch
const intelFetchSchema = z.object({
  platforms: z.array(z.string()).min(1),
  keywords: z.array(z.string()).optional().default([]),
  competitors: z.array(z.string()).optional().default([]),
  timeWindow: z.string().optional().default("24h"),
  limit: z.number().int().min(1).max(200).optional().default(50),
});

intelligenceRouter.post(
  "/intelligence/fetch",
  requireAuth,
  validateBody(intelFetchSchema),
  async (req: ValidatedRequest<z.infer<typeof intelFetchSchema>>, res: Response) => {
    try {
      const { platforms, keywords, competitors, timeWindow, limit } = req.validated!.body!;
      const signals = await strategicIntelligence.fetchMultiPlatformIntelligence({
        platforms,
        keywords,
        competitors,
        timeWindow,
        limit,
      });
      res.json({ success: true, count: signals.length, signals });
    } catch (error) {
      console.error("Error fetching intelligence:", error);
      return problem(res, 500, "Failed to fetch intelligence", (error as Error).message);
    }
  }
);

// GET /api/intelligence/trends?timeWindow=7d
const trendsQuerySchema = z.object({
  timeWindow: z.string().optional().default("7d"),
});

intelligenceRouter.get(
  "/intelligence/trends",
  requireAuth,
  validateQuery(trendsQuerySchema),
  async (req: ValidatedRequest<unknown, z.infer<typeof trendsQuerySchema>>, res: Response) => {
    try {
      const { timeWindow } = req.validated!.query!;
      const trendReport = await strategicIntelligence.detectEmergingTrends(timeWindow);
      res.json(trendReport);
    } catch (error) {
      console.error("Error analyzing trends:", error);
      return problem(res, 500, "Failed to analyze trends", (error as Error).message);
    }
  }
);

export default intelligenceRouter;
```

---

## Step 3 — Split **/api/content** CRUD + hooks into their own router

**Create file:** `server/routes/content.ts`
**PASTE EXACTLY:**

```ts
import { Router, Response } from "express";
import { requireAuth, AuthedRequest } from "../middleware/auth";
import { z } from "zod";
import { storage } from "../storage";
import { insertContentRadarSchema } from "@shared/supabase-schema";
import { problem } from "../utils/problem";
import { AIAnalyzer } from "../services/aiAnalyzer";

export const contentRouter = Router();
const aiAnalyzer = new AIAnalyzer();

// GET /api/content (with filters already applied in memory from captures)
contentRouter.get("/content", requireAuth, async (req: AuthedRequest, res: Response) => {
  try {
    const {
      type,
      platform,
      time,
      category,
      timeRange,
      sortBy,
      limit = "50",
      offset = "0",
    } = req.query as Record<string, string>;

    const captures = await storage.getUserCaptures(req.user!.id);
    let filtered = captures;

    if (platform && platform !== "all") {
      filtered = filtered.filter((c) => c.platform === platform);
    }

    const timeFilter = time || timeRange;
    if (timeFilter && timeFilter !== "all") {
      const now = new Date();
      const cutoff = new Date();
      switch (timeFilter) {
        case "1h": cutoff.setHours(now.getHours() - 1); break;
        case "24h": cutoff.setDate(now.getDate() - 1); break;
        case "7d": cutoff.setDate(now.getDate() - 7); break;
        case "30d": cutoff.setDate(now.getDate() - 30); break;
      }
      filtered = filtered.filter((c) => new Date(c.createdAt) >= cutoff);
    }

    if (type === "trending") {
      filtered = filtered
        .filter((c) => (c.viralScore && c.viralScore > 60) || c.analysisStatus === "completed" || !c.viralScore)
        .sort((a, b) => (b.viralScore || 0) - (a.viralScore || 0));
    }

    const off = parseInt(offset, 10);
    const lim = parseInt(limit, 10);

    const items = filtered.slice(off, off + lim).map((c) => ({
      id: c.id,
      title: c.title || `${c.platform} Signal`,
      description: c.summary || (c.content?.substring(0, 200) ?? "") + "...",
      platform: c.platform,
      url: c.url,
      viralScore: c.viralScore || 0,
      engagement: c.metadata?.engagement || "Unknown",
      createdAt: c.createdAt,
      tags: c.tags || [],
    }));

    res.json(items);
  } catch (error) {
    console.error("Error fetching content:", error);
    return problem(res, 500, "Failed to fetch content", (error as Error).message);
  }
});

// GET /api/content/:id
contentRouter.get("/content/:id", requireAuth, async (req: AuthedRequest, res: Response) => {
  try {
    const item = await storage.getContentItemById(req.params.id);
    if (!item) return problem(res, 404, "Content not found");
    res.json(item);
  } catch (error) {
    return problem(res, 500, "Failed to fetch content item", (error as Error).message);
  }
});

// POST /api/content
contentRouter.post("/content", requireAuth, async (req: AuthedRequest, res: Response) => {
  try {
    const validated = insertContentRadarSchema.parse(req.body);
    const item = await storage.createContentItem(validated);
    res.status(201).json(item);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return problem(res, 400, "Invalid data", "Content payload failed validation", "BAD_REQUEST", { issues: error.errors });
    }
    return problem(res, 500, "Failed to create content item", (error as Error).message);
  }
});

// PATCH /api/content/:id
contentRouter.patch("/content/:id", requireAuth, async (req: AuthedRequest, res: Response) => {
  try {
    const item = await storage.updateContentItem(req.params.id, req.body);
    if (!item) return problem(res, 404, "Content not found");
    res.json(item);
  } catch (error) {
    return problem(res, 500, "Failed to update content item", (error as Error).message);
  }
});

// DELETE /api/content/:id
contentRouter.delete("/content/:id", requireAuth, async (req: AuthedRequest, res: Response) => {
  try {
    await storage.deleteContentItem(req.params.id);
  } catch (error) {
    return problem(res, 500, "Failed to delete content item", (error as Error).message);
  }
  res.json({ success: true });
});

// POST /api/content/:id/hooks
contentRouter.post("/content/:id/hooks", requireAuth, async (req: AuthedRequest, res: Response) => {
  try {
    const item = await storage.getContentItemById(req.params.id);
    if (!item) return problem(res, 404, "Content not found");

    const existing = [item.hook1, item.hook2].filter(Boolean) as string[];
    const newHooks = await new AIAnalyzer().generateAdditionalHooks(
      item.title,
      item.content || "",
      existing
    );

    res.json({ hooks: newHooks });
  } catch (error) {
    return problem(res, 500, "Failed to generate hooks", (error as Error).message);
  }
});

// Optional: POST /api/content/scan (manual scan trigger) — keep behavior
contentRouter.post("/content/scan", requireAuth, async (req: AuthedRequest, res: Response) => {
  try {
    // If you have a scheduler service available on import:
    const { scheduler } = await import("../services/scheduler");
    const result = await scheduler.manualScan();
    res.json({
      success: result.success,
      message: `Scan completed: ${result.itemsProcessed} items processed${result.errors.length > 0 ? ` with ${result.errors.length} errors` : ""}`,
      itemsProcessed: result.itemsProcessed,
      errors: result.errors,
    });
  } catch (error) {
    return problem(res, 500, "Failed to run manual scan", (error as Error).message);
  }
});

export default contentRouter;
```

---

## Step 4 — Mount the new routers and remove old blocks

**Open:** `server/routes.ts`

1. **Add imports near the top:**

```ts
import intelligenceRouter from "./routes/intelligence";
import contentRouter from "./routes/content";
```

2. **Inside `registerRoutes(app: Express)` where other routers are mounted, ADD:**

```ts
app.use("/api", intelligenceRouter);
app.use("/api", contentRouter);
```

3. **REMOVE the original route blocks from `server/routes.ts` for these exact paths:**

* `POST /api/intelligence/fetch`
* `GET /api/intelligence/trends`
* `GET /api/content`
* `GET /api/content/:id`
* `POST /api/content`
* `PATCH /api/content/:id`
* `DELETE /api/content/:id`
* `POST /api/content/:id/hooks`
* `POST /api/content/scan`

> Delete the entire handler blocks for those endpoints (the new routers serve them).

---

## Step 5 — Typecheck and run

**Replit shell:**

```bash
npm run typecheck || npx tsc --noEmit
npm run dev
```

**Quick tests (with valid JWT in client or curl):**

* `POST /api/intelligence/fetch` with `{ "platforms": ["twitter"] }` → JSON with `success` and `signals`
* `GET /api/intelligence/trends?timeWindow=7d` → JSON report
* `GET /api/content` → array
* `POST /api/content` with a valid body for `insertContentRadarSchema` → 201 + item
* `POST /api/content/:id/hooks` → `{ hooks: [...] }`

Check server logs: you should see pretty pino logs with `requestId` for each request.

---

## Done with Phase 2 🎯

When these compile and the above endpoints work, **Phase 2 (Solidify the Architecture)** is complete:

* Modular routers
* Zod validation
* Structured logging
* Problem-details responses
* Request IDs

Say **“Phase 2 complete”** when this passes, and I’ll give you **Phase 3** (jobs off request path with a durable queue option + rate limiting polish) in the same precise format.
